var Os = Object.defineProperty;
var Ht = (r) => {
  throw TypeError(r);
};
var As = (r, e, t) => e in r ? Os(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var B = (r, e, t) => As(r, typeof e != "symbol" ? e + "" : e, t), Wt = (r, e, t) => e.has(r) || Ht("Cannot " + t);
var y = (r, e, t) => (Wt(r, e, "read from private field"), t ? t.call(r) : e.get(r)), V = (r, e, t) => e.has(r) ? Ht("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), z = (r, e, t, s) => (Wt(r, e, "write to private field"), s ? s.call(r, t) : e.set(r, t), t);
var it = (r, e, t, s) => ({
  set _(n) {
    z(r, e, n, t);
  },
  get _() {
    return y(r, e, s);
  }
});
import { B as wr, a as kr, H as zt, R as Ps } from "./RouteGuard-DRtEu9nh.js";
import { z as jr, J as Rs } from "./index-DwT-v3zK.js";
import { R as Ms, S as Is, u as bt, f as wt, g as Zs, L as Ft, O as Tr } from "./chunk-BAXFHI7N-BVBOl9s0.js";
import { S as Sr, v as Cr, Q as $s, n as U, w as Yt, x as Kt, y as ce, z as Ds, A as zs, B as Fs, C as qs, D as Gt, E as Jt, F as Ls, h as Xt, G as er, H as Bs, g as Nr, I as Er, m as Vs, e as ne, l as Be, J as Or, K as Us, f as Pe, u as Qs, j as Hs, d as Ws, Z as Ys, L as Ks, M as Gs } from "./hook-CldJlP5c.js";
import { E as Ar, S as Q, a as Js, R as Xs } from "./SlotletProvider-CS_nO-XT.js";
import { j as o } from "./jsx-runtime-C5mzlN2N.js";
import { Button as Pr } from "./ui/Button.js";
import { Callout as en } from "./ui/Callout.js";
import { M as tn } from "./mutation-DBQh7AOZ.js";
import * as fe from "react";
import ft, { createContext as qt, StrictMode as Rr, useRef as xe, useEffect as ae, useState as Ee, useCallback as ye, Suspense as Lt, memo as Mr, Component as rn, createElement as tr, useMemo as Ct, useContext as sn } from "react";
import * as nn from "react-dom";
import { CircleFadingArrowUpIcon as an, LoaderCircleIcon as on, ExternalLink as cn, CircleXIcon as dn, ChevronRightIcon as un, SearchIcon as ln, SunIcon as fn, MoonIcon as hn, MenuIcon as mn, PanelLeftIcon as pn } from "lucide-react";
import { C as kt } from "./ClientOnly-E7hGysn1.js";
import { c as q } from "./cn-qaFjX9_3.js";
import { A as gn, s as vn, a as rr, b as yn, H as xn, P as _n, c as bn, V as wn, M as kn } from "./Markdown-mFpg_n9p.js";
import { S as Ir } from "./Spinner-mNLZ6awP.js";
import { C as jn } from "./CategoryHeading-D06WK_Wo.js";
import { isSearchPlugin as Tn, isProfileMenuPlugin as Sn, isNavigationPlugin as Cn, isEventConsumerPlugin as Nn, needsInitialization as En, isApiIdentityPlugin as On, isMdxProviderPlugin as An, hasHead as Pn } from "./zudoku.plugins.js";
import { o as Rn } from "./objectEntries-yMIkr2mI.js";
import { B as Pt } from "./Button-BBNrKpQd.js";
import { DropdownMenu as Mn, DropdownMenuTrigger as In, DropdownMenuContent as Zn, DropdownMenuLabel as $n, DropdownMenuSeparator as Nt, DropdownMenuSub as Dn, DropdownMenuSubTrigger as zn, DropdownMenuPortal as Fn, DropdownMenuSubContent as qn, DropdownMenuItem as Ln } from "./ui/DropdownMenu.js";
import { VisuallyHidden as Zr } from "@radix-ui/react-visually-hidden";
import { D as Bn, a as Vn, b as $r, c as Dr, d as ie } from "./Drawer-CEwbkLDb.js";
import { a as Un } from "./index-CPNSgwSb.js";
const Rt = {}, zr = ft.createContext(Rt);
function Fr(r) {
  const e = ft.useContext(zr);
  return ft.useMemo(
    function() {
      return typeof r == "function" ? r(e) : { ...e, ...r };
    },
    [e, r]
  );
}
function Qn(r) {
  let e;
  return r.disableParentContext ? e = typeof r.components == "function" ? r.components(Rt) : r.components || Rt : e = Fr(r.components), ft.createElement(
    zr.Provider,
    { value: e },
    r.children
  );
}
var ee, xr, Hn = (xr = class extends Sr {
  constructor(e = {}) {
    super();
    V(this, ee);
    this.config = e, z(this, ee, /* @__PURE__ */ new Map());
  }
  build(e, t, s) {
    const n = t.queryKey, a = t.queryHash ?? Cr(n, t);
    let i = this.get(a);
    return i || (i = new $s({
      client: e,
      queryKey: n,
      queryHash: a,
      options: e.defaultQueryOptions(t),
      state: s,
      defaultOptions: e.getQueryDefaults(n)
    }), this.add(i)), i;
  }
  add(e) {
    y(this, ee).has(e.queryHash) || (y(this, ee).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = y(this, ee).get(e.queryHash);
    t && (e.destroy(), t === e && y(this, ee).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    U.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return y(this, ee).get(e);
  }
  getAll() {
    return [...y(this, ee).values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (s) => Yt(t, s)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((s) => Yt(e, s)) : t;
  }
  notify(e) {
    U.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    U.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    U.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, ee = new WeakMap(), xr), le, K, st, _r, Wn = (_r = class extends Sr {
  constructor(e = {}) {
    super();
    V(this, le);
    V(this, K);
    V(this, st);
    this.config = e, z(this, le, /* @__PURE__ */ new Set()), z(this, K, /* @__PURE__ */ new Map()), z(this, st, 0);
  }
  build(e, t, s) {
    const n = new tn({
      mutationCache: this,
      mutationId: ++it(this, st)._,
      options: e.defaultMutationOptions(t),
      state: s
    });
    return this.add(n), n;
  }
  add(e) {
    y(this, le).add(e);
    const t = ot(e);
    if (typeof t == "string") {
      const s = y(this, K).get(t);
      s ? s.push(e) : y(this, K).set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (y(this, le).delete(e)) {
      const t = ot(e);
      if (typeof t == "string") {
        const s = y(this, K).get(t);
        if (s)
          if (s.length > 1) {
            const n = s.indexOf(e);
            n !== -1 && s.splice(n, 1);
          } else s[0] === e && y(this, K).delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = ot(e);
    if (typeof t == "string") {
      const s = y(this, K).get(t), n = s == null ? void 0 : s.find(
        (a) => a.state.status === "pending"
      );
      return !n || n === e;
    } else
      return !0;
  }
  runNext(e) {
    var s;
    const t = ot(e);
    if (typeof t == "string") {
      const n = (s = y(this, K).get(t)) == null ? void 0 : s.find((a) => a !== e && a.state.isPaused);
      return (n == null ? void 0 : n.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    U.batch(() => {
      y(this, le).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), y(this, le).clear(), y(this, K).clear();
    });
  }
  getAll() {
    return Array.from(y(this, le));
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (s) => Kt(t, s)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => Kt(e, t));
  }
  notify(e) {
    U.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return U.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(ce))
      )
    );
  }
}, le = new WeakMap(), K = new WeakMap(), st = new WeakMap(), _r);
function ot(r) {
  var e;
  return (e = r.options.scope) == null ? void 0 : e.id;
}
function sr(r) {
  return {
    onFetch: (e, t) => {
      var f, x, w, C, k;
      const s = e.options, n = (w = (x = (f = e.fetchOptions) == null ? void 0 : f.meta) == null ? void 0 : x.fetchMore) == null ? void 0 : w.direction, a = ((C = e.state.data) == null ? void 0 : C.pages) || [], i = ((k = e.state.data) == null ? void 0 : k.pageParams) || [];
      let c = { pages: [], pageParams: [] }, u = 0;
      const d = async () => {
        let j = !1;
        const M = (N) => {
          Object.defineProperty(N, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? j = !0 : e.signal.addEventListener("abort", () => {
              j = !0;
            }), e.signal)
          });
        }, $ = Ds(e.options, e.fetchOptions), D = async (N, O, h) => {
          if (j)
            return Promise.reject();
          if (O == null && N.pages.length)
            return Promise.resolve(N);
          const R = {
            client: e.client,
            queryKey: e.queryKey,
            pageParam: O,
            direction: h ? "backward" : "forward",
            meta: e.options.meta
          };
          M(R);
          const W = await $(
            R
          ), { maxPages: Y } = e.options, oe = h ? zs : Fs;
          return {
            pages: oe(N.pages, W, Y),
            pageParams: oe(N.pageParams, O, Y)
          };
        };
        if (n && a.length) {
          const N = n === "backward", O = N ? Yn : nr, h = {
            pages: a,
            pageParams: i
          }, R = O(s, h);
          c = await D(h, R, N);
        } else {
          const N = r ?? a.length;
          do {
            const O = u === 0 ? i[0] ?? s.initialPageParam : nr(s, c);
            if (u > 0 && O == null)
              break;
            c = await D(c, O), u++;
          } while (u < N);
        }
        return c;
      };
      e.options.persister ? e.fetchFn = () => {
        var j, M;
        return (M = (j = e.options).persister) == null ? void 0 : M.call(
          j,
          d,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          t
        );
      } : e.fetchFn = d;
    }
  };
}
function nr(r, { pages: e, pageParams: t }) {
  const s = e.length - 1;
  return e.length > 0 ? r.getNextPageParam(
    e[s],
    e,
    t[s],
    t
  ) : void 0;
}
function Yn(r, { pages: e, pageParams: t }) {
  var s;
  return e.length > 0 ? (s = r.getPreviousPageParam) == null ? void 0 : s.call(r, e[0], e, t[0], t) : void 0;
}
var Z, pe, ge, Me, Ie, ve, Ze, $e, br, Kn = (br = class {
  constructor(r = {}) {
    V(this, Z);
    V(this, pe);
    V(this, ge);
    V(this, Me);
    V(this, Ie);
    V(this, ve);
    V(this, Ze);
    V(this, $e);
    z(this, Z, r.queryCache || new Hn()), z(this, pe, r.mutationCache || new Wn()), z(this, ge, r.defaultOptions || {}), z(this, Me, /* @__PURE__ */ new Map()), z(this, Ie, /* @__PURE__ */ new Map()), z(this, ve, 0);
  }
  mount() {
    it(this, ve)._++, y(this, ve) === 1 && (z(this, Ze, qs.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), y(this, Z).onFocus());
    })), z(this, $e, Gt.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), y(this, Z).onOnline());
    })));
  }
  unmount() {
    var r, e;
    it(this, ve)._--, y(this, ve) === 0 && ((r = y(this, Ze)) == null || r.call(this), z(this, Ze, void 0), (e = y(this, $e)) == null || e.call(this), z(this, $e, void 0));
  }
  isFetching(r) {
    return y(this, Z).findAll({ ...r, fetchStatus: "fetching" }).length;
  }
  isMutating(r) {
    return y(this, pe).findAll({ ...r, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(r) {
    var t;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (t = y(this, Z).get(e.queryHash)) == null ? void 0 : t.state.data;
  }
  ensureQueryData(r) {
    const e = this.defaultQueryOptions(r), t = y(this, Z).build(this, e), s = t.state.data;
    return s === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && t.isStaleByTime(Jt(e.staleTime, t)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(r) {
    return y(this, Z).findAll(r).map(({ queryKey: e, state: t }) => {
      const s = t.data;
      return [e, s];
    });
  }
  setQueryData(r, e, t) {
    const s = this.defaultQueryOptions({ queryKey: r }), n = y(this, Z).get(
      s.queryHash
    ), a = n == null ? void 0 : n.state.data, i = Ls(e, a);
    if (i !== void 0)
      return y(this, Z).build(this, s).setData(i, { ...t, manual: !0 });
  }
  setQueriesData(r, e, t) {
    return U.batch(
      () => y(this, Z).findAll(r).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, t)
      ])
    );
  }
  getQueryState(r) {
    var t;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (t = y(this, Z).get(
      e.queryHash
    )) == null ? void 0 : t.state;
  }
  removeQueries(r) {
    const e = y(this, Z);
    U.batch(() => {
      e.findAll(r).forEach((t) => {
        e.remove(t);
      });
    });
  }
  resetQueries(r, e) {
    const t = y(this, Z);
    return U.batch(() => (t.findAll(r).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...r
      },
      e
    )));
  }
  cancelQueries(r, e = {}) {
    const t = { revert: !0, ...e }, s = U.batch(
      () => y(this, Z).findAll(r).map((n) => n.cancel(t))
    );
    return Promise.all(s).then(ce).catch(ce);
  }
  invalidateQueries(r, e = {}) {
    return U.batch(() => (y(this, Z).findAll(r).forEach((t) => {
      t.invalidate();
    }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...r,
        type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(r, e = {}) {
    const t = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, s = U.batch(
      () => y(this, Z).findAll(r).filter((n) => !n.isDisabled()).map((n) => {
        let a = n.fetch(void 0, t);
        return t.throwOnError || (a = a.catch(ce)), n.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(s).then(ce);
  }
  fetchQuery(r) {
    const e = this.defaultQueryOptions(r);
    e.retry === void 0 && (e.retry = !1);
    const t = y(this, Z).build(this, e);
    return t.isStaleByTime(
      Jt(e.staleTime, t)
    ) ? t.fetch(e) : Promise.resolve(t.state.data);
  }
  prefetchQuery(r) {
    return this.fetchQuery(r).then(ce).catch(ce);
  }
  fetchInfiniteQuery(r) {
    return r.behavior = sr(r.pages), this.fetchQuery(r);
  }
  prefetchInfiniteQuery(r) {
    return this.fetchInfiniteQuery(r).then(ce).catch(ce);
  }
  ensureInfiniteQueryData(r) {
    return r.behavior = sr(r.pages), this.ensureQueryData(r);
  }
  resumePausedMutations() {
    return Gt.isOnline() ? y(this, pe).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return y(this, Z);
  }
  getMutationCache() {
    return y(this, pe);
  }
  getDefaultOptions() {
    return y(this, ge);
  }
  setDefaultOptions(r) {
    z(this, ge, r);
  }
  setQueryDefaults(r, e) {
    y(this, Me).set(Xt(r), {
      queryKey: r,
      defaultOptions: e
    });
  }
  getQueryDefaults(r) {
    const e = [...y(this, Me).values()], t = {};
    return e.forEach((s) => {
      er(r, s.queryKey) && Object.assign(t, s.defaultOptions);
    }), t;
  }
  setMutationDefaults(r, e) {
    y(this, Ie).set(Xt(r), {
      mutationKey: r,
      defaultOptions: e
    });
  }
  getMutationDefaults(r) {
    const e = [...y(this, Ie).values()], t = {};
    return e.forEach((s) => {
      er(r, s.mutationKey) && Object.assign(t, s.defaultOptions);
    }), t;
  }
  defaultQueryOptions(r) {
    if (r._defaulted)
      return r;
    const e = {
      ...y(this, ge).queries,
      ...this.getQueryDefaults(r.queryKey),
      ...r,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = Cr(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === Bs && (e.enabled = !1), e;
  }
  defaultMutationOptions(r) {
    return r != null && r._defaulted ? r : {
      ...y(this, ge).mutations,
      ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey),
      ...r,
      _defaulted: !0
    };
  }
  clear() {
    y(this, Z).clear(), y(this, pe).clear();
  }
}, Z = new WeakMap(), pe = new WeakMap(), ge = new WeakMap(), Me = new WeakMap(), Ie = new WeakMap(), ve = new WeakMap(), Ze = new WeakMap(), $e = new WeakMap(), br);
function Gn(r) {
  return r;
}
function ar(r, e, t) {
  var u, d;
  if (typeof e != "object" || e === null)
    return;
  const s = r.getMutationCache(), n = r.getQueryCache(), a = ((u = t == null ? void 0 : t.defaultOptions) == null ? void 0 : u.deserializeData) ?? ((d = r.getDefaultOptions().hydrate) == null ? void 0 : d.deserializeData) ?? Gn, i = e.mutations || [], c = e.queries || [];
  i.forEach(({ state: f, ...x }) => {
    var w, C;
    s.build(
      r,
      {
        ...(w = r.getDefaultOptions().hydrate) == null ? void 0 : w.mutations,
        ...(C = t == null ? void 0 : t.defaultOptions) == null ? void 0 : C.mutations,
        ...x
      },
      f
    );
  }), c.forEach(({ queryKey: f, state: x, queryHash: w, meta: C, promise: k }) => {
    var $, D;
    let j = n.get(w);
    const M = x.data === void 0 ? x.data : a(x.data);
    if (j) {
      if (j.state.dataUpdatedAt < x.dataUpdatedAt) {
        const { fetchStatus: N, ...O } = x;
        j.setState({
          ...O,
          data: M
        });
      }
    } else
      j = n.build(
        r,
        {
          ...($ = r.getDefaultOptions().hydrate) == null ? void 0 : $.queries,
          ...(D = t == null ? void 0 : t.defaultOptions) == null ? void 0 : D.queries,
          queryKey: f,
          queryHash: w,
          meta: C
        },
        // Reset fetch status to idle to avoid
        // query being stuck in fetching state upon hydration
        {
          ...x,
          data: M,
          fetchStatus: "idle"
        }
      );
    if (k) {
      const N = Promise.resolve(k).then(a);
      j.fetch(void 0, { initialPromise: N });
    }
  });
}
var ir = (r, e) => typeof r == "object" && r !== null && e in r, Jn = ({
  children: r,
  options: e = {},
  state: t,
  queryClient: s
}) => {
  const n = Nr(s), [a, i] = fe.useState(), c = fe.useRef(e);
  return c.current = e, fe.useMemo(() => {
    if (t) {
      if (typeof t != "object")
        return;
      const u = n.getQueryCache(), d = t.queries || [], f = [], x = [];
      for (const w of d) {
        const C = u.get(w.queryHash);
        if (!C)
          f.push(w);
        else {
          const k = w.state.dataUpdatedAt > C.state.dataUpdatedAt || // RSC special serialized then-able chunks
          ir(w.promise, "status") && ir(C.promise, "status") && w.promise.status !== C.promise.status, j = a == null ? void 0 : a.find(
            (M) => M.queryHash === w.queryHash
          );
          k && (!j || w.state.dataUpdatedAt > j.state.dataUpdatedAt) && x.push(w);
        }
      }
      f.length > 0 && ar(n, { queries: f }, c.current), x.length > 0 && i(
        (w) => w ? [...w, ...x] : x
      );
    }
  }, [n, a, t]), fe.useEffect(() => {
    a && (ar(n, { queries: a }, c.current), i(void 0));
  }, [n, a]), r;
};
function Xn({ error: r }) {
  return /* @__PURE__ */ o.jsx(Ar, { error: r });
}
/**
 * react-router v7.5.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ea(r) {
  return /* @__PURE__ */ fe.createElement(Ms, { flushSync: nn.flushSync, ...r });
}
const Mt = qt({ stagger: !1 }), ta = new Kn({
  defaultOptions: {
    queries: {
      staleTime: 1e3 * 60 * 5
    }
  }
}), ra = ({
  router: r,
  hydrate: e = !1
}) => /* @__PURE__ */ o.jsx(Rr, { children: /* @__PURE__ */ o.jsx(Er, { client: ta, children: /* @__PURE__ */ o.jsx(Jn, { state: e ? window.DATA : void 0, children: /* @__PURE__ */ o.jsx(wr, { value: !1, children: /* @__PURE__ */ o.jsx(kr, { children: /* @__PURE__ */ o.jsx(Mt.Provider, { value: { stagger: !e }, children: /* @__PURE__ */ o.jsx(ea, { router: r }) }) }) }) }) }) }), sa = ({
  router: r,
  context: e,
  queryClient: t,
  helmetContext: s,
  bypassProtection: n = !1
}) => /* @__PURE__ */ o.jsx(Rr, { children: /* @__PURE__ */ o.jsx(Er, { client: t, children: /* @__PURE__ */ o.jsx(kr, { context: s, children: /* @__PURE__ */ o.jsx(wr, { value: n, children: /* @__PURE__ */ o.jsx(Is, { router: r, context: e }) }) }) }) });
var E;
(function(r) {
  r.assertEqual = (n) => n;
  function e(n) {
  }
  r.assertIs = e;
  function t(n) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (n) => {
    const a = {};
    for (const i of n)
      a[i] = i;
    return a;
  }, r.getValidEnumValues = (n) => {
    const a = r.objectKeys(n).filter((c) => typeof n[n[c]] != "number"), i = {};
    for (const c of a)
      i[c] = n[c];
    return r.objectValues(i);
  }, r.objectValues = (n) => r.objectKeys(n).map(function(a) {
    return n[a];
  }), r.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const a = [];
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && a.push(i);
    return a;
  }, r.find = (n, a) => {
    for (const i of n)
      if (a(i))
        return i;
  }, r.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function s(n, a = " | ") {
    return n.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  r.joinValues = s, r.jsonStringifyReplacer = (n, a) => typeof a == "bigint" ? a.toString() : a;
})(E || (E = {}));
var It;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(It || (It = {}));
const p = E.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ue = (r) => {
  switch (typeof r) {
    case "undefined":
      return p.undefined;
    case "string":
      return p.string;
    case "number":
      return isNaN(r) ? p.nan : p.number;
    case "boolean":
      return p.boolean;
    case "function":
      return p.function;
    case "bigint":
      return p.bigint;
    case "symbol":
      return p.symbol;
    case "object":
      return Array.isArray(r) ? p.array : r === null ? p.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? p.promise : typeof Map < "u" && r instanceof Map ? p.map : typeof Set < "u" && r instanceof Set ? p.set : typeof Date < "u" && r instanceof Date ? p.date : p.object;
    default:
      return p.unknown;
  }
}, l = E.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), na = (r) => JSON.stringify(r, null, 2).replace(/"([^"]+)":/g, "$1:");
class H extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (s) => {
      this.issues = [...this.issues, s];
    }, this.addIssues = (s = []) => {
      this.issues = [...this.issues, ...s];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const t = e || function(a) {
      return a.message;
    }, s = { _errors: [] }, n = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(n);
        else if (i.code === "invalid_return_type")
          n(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          n(i.argumentsError);
        else if (i.path.length === 0)
          s._errors.push(t(i));
        else {
          let c = s, u = 0;
          for (; u < i.path.length; ) {
            const d = i.path[u];
            u === i.path.length - 1 ? (c[d] = c[d] || { _errors: [] }, c[d]._errors.push(t(i))) : c[d] = c[d] || { _errors: [] }, c = c[d], u++;
          }
        }
    };
    return n(this), s;
  }
  static assert(e) {
    if (!(e instanceof H))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, E.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, s = [];
    for (const n of this.issues)
      n.path.length > 0 ? (t[n.path[0]] = t[n.path[0]] || [], t[n.path[0]].push(e(n))) : s.push(e(n));
    return { formErrors: s, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
H.create = (r) => new H(r);
const De = (r, e) => {
  let t;
  switch (r.code) {
    case l.invalid_type:
      r.received === p.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case l.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, E.jsonStringifyReplacer)}`;
      break;
    case l.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${E.joinValues(r.keys, ", ")}`;
      break;
    case l.invalid_union:
      t = "Invalid input";
      break;
    case l.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${E.joinValues(r.options)}`;
      break;
    case l.invalid_enum_value:
      t = `Invalid enum value. Expected ${E.joinValues(r.options)}, received '${r.received}'`;
      break;
    case l.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case l.invalid_return_type:
      t = "Invalid function return type";
      break;
    case l.invalid_date:
      t = "Invalid date";
      break;
    case l.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : E.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case l.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case l.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case l.custom:
      t = "Invalid input";
      break;
    case l.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case l.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case l.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, E.assertNever(r);
  }
  return { message: t };
};
let qr = De;
function aa(r) {
  qr = r;
}
function ht() {
  return qr;
}
const mt = (r) => {
  const { data: e, path: t, errorMaps: s, issueData: n } = r, a = [...t, ...n.path || []], i = {
    ...n,
    path: a
  };
  if (n.message !== void 0)
    return {
      ...n,
      path: a,
      message: n.message
    };
  let c = "";
  const u = s.filter((d) => !!d).slice().reverse();
  for (const d of u)
    c = d(i, { data: e, defaultError: c }).message;
  return {
    ...n,
    path: a,
    message: c
  };
}, ia = [];
function m(r, e) {
  const t = ht(), s = mt({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      // contextual error map is first priority
      r.schemaErrorMap,
      // then schema-bound map if available
      t,
      // then global override map
      t === De ? void 0 : De
      // then global default map
    ].filter((n) => !!n)
  });
  r.common.issues.push(s);
}
class F {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const s = [];
    for (const n of t) {
      if (n.status === "aborted")
        return b;
      n.status === "dirty" && e.dirty(), s.push(n.value);
    }
    return { status: e.value, value: s };
  }
  static async mergeObjectAsync(e, t) {
    const s = [];
    for (const n of t) {
      const a = await n.key, i = await n.value;
      s.push({
        key: a,
        value: i
      });
    }
    return F.mergeObjectSync(e, s);
  }
  static mergeObjectSync(e, t) {
    const s = {};
    for (const n of t) {
      const { key: a, value: i } = n;
      if (a.status === "aborted" || i.status === "aborted")
        return b;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof i.value < "u" || n.alwaysSet) && (s[a.value] = i.value);
    }
    return { status: e.value, value: s };
  }
}
const b = Object.freeze({
  status: "aborted"
}), Ae = (r) => ({ status: "dirty", value: r }), L = (r) => ({ status: "valid", value: r }), Zt = (r) => r.status === "aborted", $t = (r) => r.status === "dirty", Se = (r) => r.status === "valid", Ve = (r) => typeof Promise < "u" && r instanceof Promise;
function pt(r, e, t, s) {
  if (typeof e == "function" ? r !== e || !0 : !e.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e.get(r);
}
function Lr(r, e, t, s, n) {
  if (typeof e == "function" ? r !== e || !0 : !e.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return e.set(r, t), t;
}
var g;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(g || (g = {}));
var qe, Le;
class re {
  constructor(e, t, s, n) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = s, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const or = (r, e) => {
  if (Se(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new H(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function T(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: s, description: n } = r;
  if (e && (t || s))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: n } : { errorMap: (i, c) => {
    var u, d;
    const { message: f } = r;
    return i.code === "invalid_enum_value" ? { message: f ?? c.defaultError } : typeof c.data > "u" ? { message: (u = f ?? s) !== null && u !== void 0 ? u : c.defaultError } : i.code !== "invalid_type" ? { message: c.defaultError } : { message: (d = f ?? t) !== null && d !== void 0 ? d : c.defaultError };
  }, description: n };
}
class S {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return ue(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: ue(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new F(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: ue(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (Ve(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const s = this.safeParse(e, t);
    if (s.success)
      return s.data;
    throw s.error;
  }
  safeParse(e, t) {
    var s;
    const n = {
      common: {
        issues: [],
        async: (s = t == null ? void 0 : t.async) !== null && s !== void 0 ? s : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ue(e)
    }, a = this._parseSync({ data: e, path: n.path, parent: n });
    return or(n, a);
  }
  "~validate"(e) {
    var t, s;
    const n = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ue(e)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: e, path: [], parent: n });
        return Se(a) ? {
          value: a.value
        } : {
          issues: n.common.issues
        };
      } catch (a) {
        !((s = (t = a == null ? void 0 : a.message) === null || t === void 0 ? void 0 : t.toLowerCase()) === null || s === void 0) && s.includes("encountered") && (this["~standard"].async = !0), n.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: n }).then((a) => Se(a) ? {
      value: a.value
    } : {
      issues: n.common.issues
    });
  }
  async parseAsync(e, t) {
    const s = await this.safeParseAsync(e, t);
    if (s.success)
      return s.data;
    throw s.error;
  }
  async safeParseAsync(e, t) {
    const s = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ue(e)
    }, n = this._parse({ data: e, path: s.path, parent: s }), a = await (Ve(n) ? n : Promise.resolve(n));
    return or(s, a);
  }
  refine(e, t) {
    const s = (n) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(n) : t;
    return this._refinement((n, a) => {
      const i = e(n), c = () => a.addIssue({
        code: l.custom,
        ...s(n)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((u) => u ? !0 : (c(), !1)) : i ? !0 : (c(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((s, n) => e(s) ? !0 : (n.addIssue(typeof t == "function" ? t(s, n) : t), !1));
  }
  _refinement(e) {
    return new X({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (t) => this["~validate"](t)
    };
  }
  optional() {
    return te.create(this, this._def);
  }
  nullable() {
    return ke.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return J.create(this);
  }
  promise() {
    return Fe.create(this, this._def);
  }
  or(e) {
    return We.create([this, e], this._def);
  }
  and(e) {
    return Ye.create(this, e, this._def);
  }
  transform(e) {
    return new X({
      ...T(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new et({
      ...T(this._def),
      innerType: this,
      defaultValue: t,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new Bt({
      typeName: _.ZodBranded,
      type: this,
      ...T(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new tt({
      ...T(this._def),
      innerType: this,
      catchValue: t,
      typeName: _.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return nt.create(this, e);
  }
  readonly() {
    return rt.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const oa = /^c[^\s-]{8,}$/i, ca = /^[0-9a-z]+$/, da = /^[0-9A-HJKMNP-TV-Z]{26}$/i, ua = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, la = /^[a-z0-9_-]{21}$/i, fa = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, ha = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, ma = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, pa = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Et;
const ga = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, va = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ya = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, xa = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, _a = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, ba = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Br = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", wa = new RegExp(`^${Br}$`);
function Vr(r) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return r.precision ? e = `${e}\\.\\d{${r.precision}}` : r.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function ka(r) {
  return new RegExp(`^${Vr(r)}$`);
}
function Ur(r) {
  let e = `${Br}T${Vr(r)}`;
  const t = [];
  return t.push(r.local ? "Z?" : "Z"), r.offset && t.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${t.join("|")})`, new RegExp(`^${e}$`);
}
function ja(r, e) {
  return !!((e === "v4" || !e) && ga.test(r) || (e === "v6" || !e) && ya.test(r));
}
function Ta(r, e) {
  if (!fa.test(r))
    return !1;
  try {
    const [t] = r.split("."), s = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "="), n = JSON.parse(atob(s));
    return !(typeof n != "object" || n === null || !n.typ || !n.alg || e && n.alg !== e);
  } catch {
    return !1;
  }
}
function Sa(r, e) {
  return !!((e === "v4" || !e) && va.test(r) || (e === "v6" || !e) && xa.test(r));
}
class G extends S {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== p.string) {
      const a = this._getOrReturnCtx(e);
      return m(a, {
        code: l.invalid_type,
        expected: p.string,
        received: a.parsedType
      }), b;
    }
    const s = new F();
    let n;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (n = this._getOrReturnCtx(e, n), m(n, {
          code: l.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), s.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (n = this._getOrReturnCtx(e, n), m(n, {
          code: l.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), s.dirty());
      else if (a.kind === "length") {
        const i = e.data.length > a.value, c = e.data.length < a.value;
        (i || c) && (n = this._getOrReturnCtx(e, n), i ? m(n, {
          code: l.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : c && m(n, {
          code: l.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), s.dirty());
      } else if (a.kind === "email")
        ma.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "email",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "emoji")
        Et || (Et = new RegExp(pa, "u")), Et.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "emoji",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "uuid")
        ua.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "uuid",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "nanoid")
        la.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "nanoid",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "cuid")
        oa.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "cuid",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "cuid2")
        ca.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "cuid2",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "ulid")
        da.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
          validation: "ulid",
          code: l.invalid_string,
          message: a.message
        }), s.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          n = this._getOrReturnCtx(e, n), m(n, {
            validation: "url",
            code: l.invalid_string,
            message: a.message
          }), s.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "regex",
        code: l.invalid_string,
        message: a.message
      }), s.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), s.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), s.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), s.dirty()) : a.kind === "datetime" ? Ur(a).test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: "datetime",
        message: a.message
      }), s.dirty()) : a.kind === "date" ? wa.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: "date",
        message: a.message
      }), s.dirty()) : a.kind === "time" ? ka(a).test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.invalid_string,
        validation: "time",
        message: a.message
      }), s.dirty()) : a.kind === "duration" ? ha.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "duration",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : a.kind === "ip" ? ja(e.data, a.version) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "ip",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : a.kind === "jwt" ? Ta(e.data, a.alg) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "jwt",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : a.kind === "cidr" ? Sa(e.data, a.version) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "cidr",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : a.kind === "base64" ? _a.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "base64",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : a.kind === "base64url" ? ba.test(e.data) || (n = this._getOrReturnCtx(e, n), m(n, {
        validation: "base64url",
        code: l.invalid_string,
        message: a.message
      }), s.dirty()) : E.assertNever(a);
    return { status: s.value, value: e.data };
  }
  _regex(e, t, s) {
    return this.refinement((n) => e.test(n), {
      validation: t,
      code: l.invalid_string,
      ...g.errToObj(s)
    });
  }
  _addCheck(e) {
    return new G({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...g.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...g.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...g.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...g.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...g.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...g.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...g.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...g.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...g.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...g.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...g.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...g.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...g.errToObj(e) });
  }
  datetime(e) {
    var t, s;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      local: (s = e == null ? void 0 : e.local) !== null && s !== void 0 ? s : !1,
      ...g.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...g.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...g.errToObj(e) });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...g.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...g.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...g.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...g.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...g.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...g.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...g.errToObj(t)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, g.errToObj(e));
  }
  trim() {
    return new G({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new G({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new G({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
G.create = (r) => {
  var e;
  return new G({
    checks: [],
    typeName: _.ZodString,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...T(r)
  });
};
function Ca(r, e) {
  const t = (r.toString().split(".")[1] || "").length, s = (e.toString().split(".")[1] || "").length, n = t > s ? t : s, a = parseInt(r.toFixed(n).replace(".", "")), i = parseInt(e.toFixed(n).replace(".", ""));
  return a % i / Math.pow(10, n);
}
class _e extends S {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== p.number) {
      const a = this._getOrReturnCtx(e);
      return m(a, {
        code: l.invalid_type,
        expected: p.number,
        received: a.parsedType
      }), b;
    }
    let s;
    const n = new F();
    for (const a of this._def.checks)
      a.kind === "int" ? E.isInteger(e.data) || (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), n.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), n.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), n.dirty()) : a.kind === "multipleOf" ? Ca(e.data, a.value) !== 0 && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), n.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.not_finite,
        message: a.message
      }), n.dirty()) : E.assertNever(a);
    return { status: n.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, g.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, g.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, g.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, g.toString(t));
  }
  setLimit(e, t, s, n) {
    return new _e({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: s,
          message: g.toString(n)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _e({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: g.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: g.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: g.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: g.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: g.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && E.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const s of this._def.checks) {
      if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
        return !0;
      s.kind === "min" ? (t === null || s.value > t) && (t = s.value) : s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
_e.create = (r) => new _e({
  checks: [],
  typeName: _.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...T(r)
});
class be extends S {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== p.bigint)
      return this._getInvalidInput(e);
    let s;
    const n = new F();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), n.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), n.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (s = this._getOrReturnCtx(e, s), m(s, {
        code: l.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), n.dirty()) : E.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _getInvalidInput(e) {
    const t = this._getOrReturnCtx(e);
    return m(t, {
      code: l.invalid_type,
      expected: p.bigint,
      received: t.parsedType
    }), b;
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, g.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, g.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, g.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, g.toString(t));
  }
  setLimit(e, t, s, n) {
    return new be({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: s,
          message: g.toString(n)
        }
      ]
    });
  }
  _addCheck(e) {
    return new be({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: g.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
be.create = (r) => {
  var e;
  return new be({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...T(r)
  });
};
class Ue extends S {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== p.boolean) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.boolean,
        received: s.parsedType
      }), b;
    }
    return L(e.data);
  }
}
Ue.create = (r) => new Ue({
  typeName: _.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...T(r)
});
class Ce extends S {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== p.date) {
      const a = this._getOrReturnCtx(e);
      return m(a, {
        code: l.invalid_type,
        expected: p.date,
        received: a.parsedType
      }), b;
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return m(a, {
        code: l.invalid_date
      }), b;
    }
    const s = new F();
    let n;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), s.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (n = this._getOrReturnCtx(e, n), m(n, {
        code: l.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), s.dirty()) : E.assertNever(a);
    return {
      status: s.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Ce({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: g.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: g.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
Ce.create = (r) => new Ce({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: _.ZodDate,
  ...T(r)
});
class gt extends S {
  _parse(e) {
    if (this._getType(e) !== p.symbol) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.symbol,
        received: s.parsedType
      }), b;
    }
    return L(e.data);
  }
}
gt.create = (r) => new gt({
  typeName: _.ZodSymbol,
  ...T(r)
});
class Qe extends S {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.undefined,
        received: s.parsedType
      }), b;
    }
    return L(e.data);
  }
}
Qe.create = (r) => new Qe({
  typeName: _.ZodUndefined,
  ...T(r)
});
class He extends S {
  _parse(e) {
    if (this._getType(e) !== p.null) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.null,
        received: s.parsedType
      }), b;
    }
    return L(e.data);
  }
}
He.create = (r) => new He({
  typeName: _.ZodNull,
  ...T(r)
});
class ze extends S {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
ze.create = (r) => new ze({
  typeName: _.ZodAny,
  ...T(r)
});
class Te extends S {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
Te.create = (r) => new Te({
  typeName: _.ZodUnknown,
  ...T(r)
});
class he extends S {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return m(t, {
      code: l.invalid_type,
      expected: p.never,
      received: t.parsedType
    }), b;
  }
}
he.create = (r) => new he({
  typeName: _.ZodNever,
  ...T(r)
});
class vt extends S {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.void,
        received: s.parsedType
      }), b;
    }
    return L(e.data);
  }
}
vt.create = (r) => new vt({
  typeName: _.ZodVoid,
  ...T(r)
});
class J extends S {
  _parse(e) {
    const { ctx: t, status: s } = this._processInputParams(e), n = this._def;
    if (t.parsedType !== p.array)
      return m(t, {
        code: l.invalid_type,
        expected: p.array,
        received: t.parsedType
      }), b;
    if (n.exactLength !== null) {
      const i = t.data.length > n.exactLength.value, c = t.data.length < n.exactLength.value;
      (i || c) && (m(t, {
        code: i ? l.too_big : l.too_small,
        minimum: c ? n.exactLength.value : void 0,
        maximum: i ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), s.dirty());
    }
    if (n.minLength !== null && t.data.length < n.minLength.value && (m(t, {
      code: l.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), s.dirty()), n.maxLength !== null && t.data.length > n.maxLength.value && (m(t, {
      code: l.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), s.dirty()), t.common.async)
      return Promise.all([...t.data].map((i, c) => n.type._parseAsync(new re(t, i, t.path, c)))).then((i) => F.mergeArray(s, i));
    const a = [...t.data].map((i, c) => n.type._parseSync(new re(t, i, t.path, c)));
    return F.mergeArray(s, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new J({
      ...this._def,
      minLength: { value: e, message: g.toString(t) }
    });
  }
  max(e, t) {
    return new J({
      ...this._def,
      maxLength: { value: e, message: g.toString(t) }
    });
  }
  length(e, t) {
    return new J({
      ...this._def,
      exactLength: { value: e, message: g.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
J.create = (r, e) => new J({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...T(e)
});
function Oe(r) {
  if (r instanceof I) {
    const e = {};
    for (const t in r.shape) {
      const s = r.shape[t];
      e[t] = te.create(Oe(s));
    }
    return new I({
      ...r._def,
      shape: () => e
    });
  } else return r instanceof J ? new J({
    ...r._def,
    type: Oe(r.element)
  }) : r instanceof te ? te.create(Oe(r.unwrap())) : r instanceof ke ? ke.create(Oe(r.unwrap())) : r instanceof se ? se.create(r.items.map((e) => Oe(e))) : r;
}
class I extends S {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = E.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== p.object) {
      const d = this._getOrReturnCtx(e);
      return m(d, {
        code: l.invalid_type,
        expected: p.object,
        received: d.parsedType
      }), b;
    }
    const { status: s, ctx: n } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), c = [];
    if (!(this._def.catchall instanceof he && this._def.unknownKeys === "strip"))
      for (const d in n.data)
        i.includes(d) || c.push(d);
    const u = [];
    for (const d of i) {
      const f = a[d], x = n.data[d];
      u.push({
        key: { status: "valid", value: d },
        value: f._parse(new re(n, x, n.path, d)),
        alwaysSet: d in n.data
      });
    }
    if (this._def.catchall instanceof he) {
      const d = this._def.unknownKeys;
      if (d === "passthrough")
        for (const f of c)
          u.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: n.data[f] }
          });
      else if (d === "strict")
        c.length > 0 && (m(n, {
          code: l.unrecognized_keys,
          keys: c
        }), s.dirty());
      else if (d !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const d = this._def.catchall;
      for (const f of c) {
        const x = n.data[f];
        u.push({
          key: { status: "valid", value: f },
          value: d._parse(
            new re(n, x, n.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const d = [];
      for (const f of u) {
        const x = await f.key, w = await f.value;
        d.push({
          key: x,
          value: w,
          alwaysSet: f.alwaysSet
        });
      }
      return d;
    }).then((d) => F.mergeObjectSync(s, d)) : F.mergeObjectSync(s, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return g.errToObj, new I({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, s) => {
          var n, a, i, c;
          const u = (i = (a = (n = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(n, t, s).message) !== null && i !== void 0 ? i : s.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (c = g.errToObj(e).message) !== null && c !== void 0 ? c : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new I({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new I({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new I({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new I({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new I({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return E.objectKeys(e).forEach((s) => {
      e[s] && this.shape[s] && (t[s] = this.shape[s]);
    }), new I({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return E.objectKeys(this.shape).forEach((s) => {
      e[s] || (t[s] = this.shape[s]);
    }), new I({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Oe(this);
  }
  partial(e) {
    const t = {};
    return E.objectKeys(this.shape).forEach((s) => {
      const n = this.shape[s];
      e && !e[s] ? t[s] = n : t[s] = n.optional();
    }), new I({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return E.objectKeys(this.shape).forEach((s) => {
      if (e && !e[s])
        t[s] = this.shape[s];
      else {
        let a = this.shape[s];
        for (; a instanceof te; )
          a = a._def.innerType;
        t[s] = a;
      }
    }), new I({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return Qr(E.objectKeys(this.shape));
  }
}
I.create = (r, e) => new I({
  shape: () => r,
  unknownKeys: "strip",
  catchall: he.create(),
  typeName: _.ZodObject,
  ...T(e)
});
I.strictCreate = (r, e) => new I({
  shape: () => r,
  unknownKeys: "strict",
  catchall: he.create(),
  typeName: _.ZodObject,
  ...T(e)
});
I.lazycreate = (r, e) => new I({
  shape: r,
  unknownKeys: "strip",
  catchall: he.create(),
  typeName: _.ZodObject,
  ...T(e)
});
class We extends S {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), s = this._def.options;
    function n(a) {
      for (const c of a)
        if (c.result.status === "valid")
          return c.result;
      for (const c of a)
        if (c.result.status === "dirty")
          return t.common.issues.push(...c.ctx.common.issues), c.result;
      const i = a.map((c) => new H(c.ctx.common.issues));
      return m(t, {
        code: l.invalid_union,
        unionErrors: i
      }), b;
    }
    if (t.common.async)
      return Promise.all(s.map(async (a) => {
        const i = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: t.data,
            path: t.path,
            parent: i
          }),
          ctx: i
        };
      })).then(n);
    {
      let a;
      const i = [];
      for (const u of s) {
        const d = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, f = u._parseSync({
          data: t.data,
          path: t.path,
          parent: d
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !a && (a = { result: f, ctx: d }), d.common.issues.length && i.push(d.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      const c = i.map((u) => new H(u));
      return m(t, {
        code: l.invalid_union,
        unionErrors: c
      }), b;
    }
  }
  get options() {
    return this._def.options;
  }
}
We.create = (r, e) => new We({
  options: r,
  typeName: _.ZodUnion,
  ...T(e)
});
const de = (r) => r instanceof Ge ? de(r.schema) : r instanceof X ? de(r.innerType()) : r instanceof Je ? [r.value] : r instanceof we ? r.options : r instanceof Xe ? E.objectValues(r.enum) : r instanceof et ? de(r._def.innerType) : r instanceof Qe ? [void 0] : r instanceof He ? [null] : r instanceof te ? [void 0, ...de(r.unwrap())] : r instanceof ke ? [null, ...de(r.unwrap())] : r instanceof Bt || r instanceof rt ? de(r.unwrap()) : r instanceof tt ? de(r._def.innerType) : [];
class jt extends S {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== p.object)
      return m(t, {
        code: l.invalid_type,
        expected: p.object,
        received: t.parsedType
      }), b;
    const s = this.discriminator, n = t.data[s], a = this.optionsMap.get(n);
    return a ? t.common.async ? a._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : a._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (m(t, {
      code: l.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [s]
    }), b);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, s) {
    const n = /* @__PURE__ */ new Map();
    for (const a of t) {
      const i = de(a.shape[e]);
      if (!i.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const c of i) {
        if (n.has(c))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(c)}`);
        n.set(c, a);
      }
    }
    return new jt({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: n,
      ...T(s)
    });
  }
}
function Dt(r, e) {
  const t = ue(r), s = ue(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === p.object && s === p.object) {
    const n = E.objectKeys(e), a = E.objectKeys(r).filter((c) => n.indexOf(c) !== -1), i = { ...r, ...e };
    for (const c of a) {
      const u = Dt(r[c], e[c]);
      if (!u.valid)
        return { valid: !1 };
      i[c] = u.data;
    }
    return { valid: !0, data: i };
  } else if (t === p.array && s === p.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const n = [];
    for (let a = 0; a < r.length; a++) {
      const i = r[a], c = e[a], u = Dt(i, c);
      if (!u.valid)
        return { valid: !1 };
      n.push(u.data);
    }
    return { valid: !0, data: n };
  } else return t === p.date && s === p.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
class Ye extends S {
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e), n = (a, i) => {
      if (Zt(a) || Zt(i))
        return b;
      const c = Dt(a.value, i.value);
      return c.valid ? (($t(a) || $t(i)) && t.dirty(), { status: t.value, value: c.data }) : (m(s, {
        code: l.invalid_intersection_types
      }), b);
    };
    return s.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      }),
      this._def.right._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      })
    ]).then(([a, i]) => n(a, i)) : n(this._def.left._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }), this._def.right._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }));
  }
}
Ye.create = (r, e, t) => new Ye({
  left: r,
  right: e,
  typeName: _.ZodIntersection,
  ...T(t)
});
class se extends S {
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== p.array)
      return m(s, {
        code: l.invalid_type,
        expected: p.array,
        received: s.parsedType
      }), b;
    if (s.data.length < this._def.items.length)
      return m(s, {
        code: l.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), b;
    !this._def.rest && s.data.length > this._def.items.length && (m(s, {
      code: l.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const a = [...s.data].map((i, c) => {
      const u = this._def.items[c] || this._def.rest;
      return u ? u._parse(new re(s, i, s.path, c)) : null;
    }).filter((i) => !!i);
    return s.common.async ? Promise.all(a).then((i) => F.mergeArray(t, i)) : F.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new se({
      ...this._def,
      rest: e
    });
  }
}
se.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new se({
    items: r,
    typeName: _.ZodTuple,
    rest: null,
    ...T(e)
  });
};
class Ke extends S {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== p.object)
      return m(s, {
        code: l.invalid_type,
        expected: p.object,
        received: s.parsedType
      }), b;
    const n = [], a = this._def.keyType, i = this._def.valueType;
    for (const c in s.data)
      n.push({
        key: a._parse(new re(s, c, s.path, c)),
        value: i._parse(new re(s, s.data[c], s.path, c)),
        alwaysSet: c in s.data
      });
    return s.common.async ? F.mergeObjectAsync(t, n) : F.mergeObjectSync(t, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, s) {
    return t instanceof S ? new Ke({
      keyType: e,
      valueType: t,
      typeName: _.ZodRecord,
      ...T(s)
    }) : new Ke({
      keyType: G.create(),
      valueType: e,
      typeName: _.ZodRecord,
      ...T(t)
    });
  }
}
class yt extends S {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== p.map)
      return m(s, {
        code: l.invalid_type,
        expected: p.map,
        received: s.parsedType
      }), b;
    const n = this._def.keyType, a = this._def.valueType, i = [...s.data.entries()].map(([c, u], d) => ({
      key: n._parse(new re(s, c, s.path, [d, "key"])),
      value: a._parse(new re(s, u, s.path, [d, "value"]))
    }));
    if (s.common.async) {
      const c = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of i) {
          const d = await u.key, f = await u.value;
          if (d.status === "aborted" || f.status === "aborted")
            return b;
          (d.status === "dirty" || f.status === "dirty") && t.dirty(), c.set(d.value, f.value);
        }
        return { status: t.value, value: c };
      });
    } else {
      const c = /* @__PURE__ */ new Map();
      for (const u of i) {
        const d = u.key, f = u.value;
        if (d.status === "aborted" || f.status === "aborted")
          return b;
        (d.status === "dirty" || f.status === "dirty") && t.dirty(), c.set(d.value, f.value);
      }
      return { status: t.value, value: c };
    }
  }
}
yt.create = (r, e, t) => new yt({
  valueType: e,
  keyType: r,
  typeName: _.ZodMap,
  ...T(t)
});
class Ne extends S {
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e);
    if (s.parsedType !== p.set)
      return m(s, {
        code: l.invalid_type,
        expected: p.set,
        received: s.parsedType
      }), b;
    const n = this._def;
    n.minSize !== null && s.data.size < n.minSize.value && (m(s, {
      code: l.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), t.dirty()), n.maxSize !== null && s.data.size > n.maxSize.value && (m(s, {
      code: l.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), t.dirty());
    const a = this._def.valueType;
    function i(u) {
      const d = /* @__PURE__ */ new Set();
      for (const f of u) {
        if (f.status === "aborted")
          return b;
        f.status === "dirty" && t.dirty(), d.add(f.value);
      }
      return { status: t.value, value: d };
    }
    const c = [...s.data.values()].map((u, d) => a._parse(new re(s, u, s.path, d)));
    return s.common.async ? Promise.all(c).then((u) => i(u)) : i(c);
  }
  min(e, t) {
    return new Ne({
      ...this._def,
      minSize: { value: e, message: g.toString(t) }
    });
  }
  max(e, t) {
    return new Ne({
      ...this._def,
      maxSize: { value: e, message: g.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ne.create = (r, e) => new Ne({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...T(e)
});
class Re extends S {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== p.function)
      return m(t, {
        code: l.invalid_type,
        expected: p.function,
        received: t.parsedType
      }), b;
    function s(c, u) {
      return mt({
        data: c,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          ht(),
          De
        ].filter((d) => !!d),
        issueData: {
          code: l.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function n(c, u) {
      return mt({
        data: c,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          ht(),
          De
        ].filter((d) => !!d),
        issueData: {
          code: l.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const a = { errorMap: t.common.contextualErrorMap }, i = t.data;
    if (this._def.returns instanceof Fe) {
      const c = this;
      return L(async function(...u) {
        const d = new H([]), f = await c._def.args.parseAsync(u, a).catch((C) => {
          throw d.addIssue(s(u, C)), d;
        }), x = await Reflect.apply(i, this, f);
        return await c._def.returns._def.type.parseAsync(x, a).catch((C) => {
          throw d.addIssue(n(x, C)), d;
        });
      });
    } else {
      const c = this;
      return L(function(...u) {
        const d = c._def.args.safeParse(u, a);
        if (!d.success)
          throw new H([s(u, d.error)]);
        const f = Reflect.apply(i, this, d.data), x = c._def.returns.safeParse(f, a);
        if (!x.success)
          throw new H([n(f, x.error)]);
        return x.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Re({
      ...this._def,
      args: se.create(e).rest(Te.create())
    });
  }
  returns(e) {
    return new Re({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, s) {
    return new Re({
      args: e || se.create([]).rest(Te.create()),
      returns: t || Te.create(),
      typeName: _.ZodFunction,
      ...T(s)
    });
  }
}
class Ge extends S {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Ge.create = (r, e) => new Ge({
  getter: r,
  typeName: _.ZodLazy,
  ...T(e)
});
class Je extends S {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return m(t, {
        received: t.data,
        code: l.invalid_literal,
        expected: this._def.value
      }), b;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Je.create = (r, e) => new Je({
  value: r,
  typeName: _.ZodLiteral,
  ...T(e)
});
function Qr(r, e) {
  return new we({
    values: r,
    typeName: _.ZodEnum,
    ...T(e)
  });
}
class we extends S {
  constructor() {
    super(...arguments), qe.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), s = this._def.values;
      return m(t, {
        expected: E.joinValues(s),
        received: t.parsedType,
        code: l.invalid_type
      }), b;
    }
    if (pt(this, qe) || Lr(this, qe, new Set(this._def.values)), !pt(this, qe).has(e.data)) {
      const t = this._getOrReturnCtx(e), s = this._def.values;
      return m(t, {
        received: t.data,
        code: l.invalid_enum_value,
        options: s
      }), b;
    }
    return L(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e, t = this._def) {
    return we.create(e, {
      ...this._def,
      ...t
    });
  }
  exclude(e, t = this._def) {
    return we.create(this.options.filter((s) => !e.includes(s)), {
      ...this._def,
      ...t
    });
  }
}
qe = /* @__PURE__ */ new WeakMap();
we.create = Qr;
class Xe extends S {
  constructor() {
    super(...arguments), Le.set(this, void 0);
  }
  _parse(e) {
    const t = E.getValidEnumValues(this._def.values), s = this._getOrReturnCtx(e);
    if (s.parsedType !== p.string && s.parsedType !== p.number) {
      const n = E.objectValues(t);
      return m(s, {
        expected: E.joinValues(n),
        received: s.parsedType,
        code: l.invalid_type
      }), b;
    }
    if (pt(this, Le) || Lr(this, Le, new Set(E.getValidEnumValues(this._def.values))), !pt(this, Le).has(e.data)) {
      const n = E.objectValues(t);
      return m(s, {
        received: s.data,
        code: l.invalid_enum_value,
        options: n
      }), b;
    }
    return L(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Le = /* @__PURE__ */ new WeakMap();
Xe.create = (r, e) => new Xe({
  values: r,
  typeName: _.ZodNativeEnum,
  ...T(e)
});
class Fe extends S {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== p.promise && t.common.async === !1)
      return m(t, {
        code: l.invalid_type,
        expected: p.promise,
        received: t.parsedType
      }), b;
    const s = t.parsedType === p.promise ? t.data : Promise.resolve(t.data);
    return L(s.then((n) => this._def.type.parseAsync(n, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
Fe.create = (r, e) => new Fe({
  type: r,
  typeName: _.ZodPromise,
  ...T(e)
});
class X extends S {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e), n = this._def.effect || null, a = {
      addIssue: (i) => {
        m(s, i), i.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return s.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), n.type === "preprocess") {
      const i = n.transform(s.data, a);
      if (s.common.async)
        return Promise.resolve(i).then(async (c) => {
          if (t.value === "aborted")
            return b;
          const u = await this._def.schema._parseAsync({
            data: c,
            path: s.path,
            parent: s
          });
          return u.status === "aborted" ? b : u.status === "dirty" || t.value === "dirty" ? Ae(u.value) : u;
        });
      {
        if (t.value === "aborted")
          return b;
        const c = this._def.schema._parseSync({
          data: i,
          path: s.path,
          parent: s
        });
        return c.status === "aborted" ? b : c.status === "dirty" || t.value === "dirty" ? Ae(c.value) : c;
      }
    }
    if (n.type === "refinement") {
      const i = (c) => {
        const u = n.refinement(c, a);
        if (s.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return c;
      };
      if (s.common.async === !1) {
        const c = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return c.status === "aborted" ? b : (c.status === "dirty" && t.dirty(), i(c.value), { status: t.value, value: c.value });
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((c) => c.status === "aborted" ? b : (c.status === "dirty" && t.dirty(), i(c.value).then(() => ({ status: t.value, value: c.value }))));
    }
    if (n.type === "transform")
      if (s.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        if (!Se(i))
          return i;
        const c = n.transform(i.value, a);
        if (c instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: c };
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((i) => Se(i) ? Promise.resolve(n.transform(i.value, a)).then((c) => ({ status: t.value, value: c })) : i);
    E.assertNever(n);
  }
}
X.create = (r, e, t) => new X({
  schema: r,
  typeName: _.ZodEffects,
  effect: e,
  ...T(t)
});
X.createWithPreprocess = (r, e, t) => new X({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: _.ZodEffects,
  ...T(t)
});
class te extends S {
  _parse(e) {
    return this._getType(e) === p.undefined ? L(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
te.create = (r, e) => new te({
  innerType: r,
  typeName: _.ZodOptional,
  ...T(e)
});
class ke extends S {
  _parse(e) {
    return this._getType(e) === p.null ? L(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ke.create = (r, e) => new ke({
  innerType: r,
  typeName: _.ZodNullable,
  ...T(e)
});
class et extends S {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let s = t.data;
    return t.parsedType === p.undefined && (s = this._def.defaultValue()), this._def.innerType._parse({
      data: s,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
et.create = (r, e) => new et({
  innerType: r,
  typeName: _.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...T(e)
});
class tt extends S {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), s = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: s.data,
      path: s.path,
      parent: {
        ...s
      }
    });
    return Ve(n) ? n.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new H(s.common.issues);
        },
        input: s.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new H(s.common.issues);
        },
        input: s.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
tt.create = (r, e) => new tt({
  innerType: r,
  typeName: _.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...T(e)
});
class xt extends S {
  _parse(e) {
    if (this._getType(e) !== p.nan) {
      const s = this._getOrReturnCtx(e);
      return m(s, {
        code: l.invalid_type,
        expected: p.nan,
        received: s.parsedType
      }), b;
    }
    return { status: "valid", value: e.data };
  }
}
xt.create = (r) => new xt({
  typeName: _.ZodNaN,
  ...T(r)
});
const Na = Symbol("zod_brand");
class Bt extends S {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), s = t.data;
    return this._def.type._parse({
      data: s,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class nt extends S {
  _parse(e) {
    const { status: t, ctx: s } = this._processInputParams(e);
    if (s.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? b : a.status === "dirty" ? (t.dirty(), Ae(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: s.path,
          parent: s
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: s.data,
        path: s.path,
        parent: s
      });
      return n.status === "aborted" ? b : n.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: s.path,
        parent: s
      });
    }
  }
  static create(e, t) {
    return new nt({
      in: e,
      out: t,
      typeName: _.ZodPipeline
    });
  }
}
class rt extends S {
  _parse(e) {
    const t = this._def.innerType._parse(e), s = (n) => (Se(n) && (n.value = Object.freeze(n.value)), n);
    return Ve(t) ? t.then((n) => s(n)) : s(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
rt.create = (r, e) => new rt({
  innerType: r,
  typeName: _.ZodReadonly,
  ...T(e)
});
function cr(r, e) {
  const t = typeof r == "function" ? r(e) : typeof r == "string" ? { message: r } : r;
  return typeof t == "string" ? { message: t } : t;
}
function Hr(r, e = {}, t) {
  return r ? ze.create().superRefine((s, n) => {
    var a, i;
    const c = r(s);
    if (c instanceof Promise)
      return c.then((u) => {
        var d, f;
        if (!u) {
          const x = cr(e, s), w = (f = (d = x.fatal) !== null && d !== void 0 ? d : t) !== null && f !== void 0 ? f : !0;
          n.addIssue({ code: "custom", ...x, fatal: w });
        }
      });
    if (!c) {
      const u = cr(e, s), d = (i = (a = u.fatal) !== null && a !== void 0 ? a : t) !== null && i !== void 0 ? i : !0;
      n.addIssue({ code: "custom", ...u, fatal: d });
    }
  }) : ze.create();
}
const Ea = {
  object: I.lazycreate
};
var _;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
const Oa = (r, e = {
  message: `Input not instance of ${r.name}`
}) => Hr((t) => t instanceof r, e), Wr = G.create, Yr = _e.create, Aa = xt.create, Pa = be.create, Kr = Ue.create, Ra = Ce.create, Ma = gt.create, Ia = Qe.create, Za = He.create, $a = ze.create, Da = Te.create, za = he.create, Fa = vt.create, qa = J.create, La = I.create, Ba = I.strictCreate, Va = We.create, Ua = jt.create, Qa = Ye.create, Ha = se.create, Wa = Ke.create, Ya = yt.create, Ka = Ne.create, Ga = Re.create, Ja = Ge.create, Xa = Je.create, ei = we.create, ti = Xe.create, ri = Fe.create, dr = X.create, si = te.create, ni = ke.create, ai = X.createWithPreprocess, ii = nt.create, oi = () => Wr().optional(), ci = () => Yr().optional(), di = () => Kr().optional(), ui = {
  string: (r) => G.create({ ...r, coerce: !0 }),
  number: (r) => _e.create({ ...r, coerce: !0 }),
  boolean: (r) => Ue.create({
    ...r,
    coerce: !0
  }),
  bigint: (r) => be.create({ ...r, coerce: !0 }),
  date: (r) => Ce.create({ ...r, coerce: !0 })
}, li = b;
var ct = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: De,
  setErrorMap: aa,
  getErrorMap: ht,
  makeIssue: mt,
  EMPTY_PATH: ia,
  addIssueToContext: m,
  ParseStatus: F,
  INVALID: b,
  DIRTY: Ae,
  OK: L,
  isAborted: Zt,
  isDirty: $t,
  isValid: Se,
  isAsync: Ve,
  get util() {
    return E;
  },
  get objectUtil() {
    return It;
  },
  ZodParsedType: p,
  getParsedType: ue,
  ZodType: S,
  datetimeRegex: Ur,
  ZodString: G,
  ZodNumber: _e,
  ZodBigInt: be,
  ZodBoolean: Ue,
  ZodDate: Ce,
  ZodSymbol: gt,
  ZodUndefined: Qe,
  ZodNull: He,
  ZodAny: ze,
  ZodUnknown: Te,
  ZodNever: he,
  ZodVoid: vt,
  ZodArray: J,
  ZodObject: I,
  ZodUnion: We,
  ZodDiscriminatedUnion: jt,
  ZodIntersection: Ye,
  ZodTuple: se,
  ZodRecord: Ke,
  ZodMap: yt,
  ZodSet: Ne,
  ZodFunction: Re,
  ZodLazy: Ge,
  ZodLiteral: Je,
  ZodEnum: we,
  ZodNativeEnum: Xe,
  ZodPromise: Fe,
  ZodEffects: X,
  ZodTransformer: X,
  ZodOptional: te,
  ZodNullable: ke,
  ZodDefault: et,
  ZodCatch: tt,
  ZodNaN: xt,
  BRAND: Na,
  ZodBranded: Bt,
  ZodPipeline: nt,
  ZodReadonly: rt,
  custom: Hr,
  Schema: S,
  ZodSchema: S,
  late: Ea,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: ui,
  any: $a,
  array: qa,
  bigint: Pa,
  boolean: Kr,
  date: Ra,
  discriminatedUnion: Ua,
  effect: dr,
  enum: ei,
  function: Ga,
  instanceof: Oa,
  intersection: Qa,
  lazy: Ja,
  literal: Xa,
  map: Ya,
  nan: Aa,
  nativeEnum: ti,
  never: za,
  null: Za,
  nullable: ni,
  number: Yr,
  object: La,
  oboolean: di,
  onumber: ci,
  optional: si,
  ostring: oi,
  pipeline: ii,
  preprocess: ai,
  promise: ri,
  record: Wa,
  set: Ka,
  strictObject: Ba,
  string: Wr,
  symbol: Ma,
  transformer: dr,
  tuple: Ha,
  undefined: Ia,
  union: Va,
  unknown: Da,
  void: Fa,
  NEVER: li,
  ZodIssueCode: l,
  quotelessJson: na,
  ZodError: H
});
const fi = ct.object({
  buildId: ct.string(),
  timestamp: ct.string(),
  status: ct.enum(["in-progress", "success", "failed"])
}), hi = ({
  buildId: r,
  endpoint: e = "/__zuplo/docs"
}) => {
  const t = Vs({
    queryKey: ["zuplo-build-check", r, e],
    refetchInterval: 3e3,
    enabled: typeof r < "u" && !1,
    retry: !1,
    queryFn: () => fetch(e, { signal: AbortSignal.timeout(2e3) }).then((n) => {
      if (!n.ok) throw new Error("Failed to fetch build status");
      return n.json();
    }).then((n) => fi.parse(n))
  });
  if (t.isError || !t.data || t.data.buildId === r)
    return null;
  const s = t.data.status === "success";
  return /* @__PURE__ */ o.jsxs("div", { className: "fixed flex flex-col gap-3 p-4 rounded-xl w-96 border z-20 bg-background left-0 right-0 top-4 mx-auto shadow-lg", children: [
    s ? /* @__PURE__ */ o.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ o.jsx(an, { size: 16 }),
      /* @__PURE__ */ o.jsx("span", { className: "text-sm", children: "New version available" })
    ] }) : /* @__PURE__ */ o.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ o.jsx(on, { size: 16, className: "animate-spin" }),
      /* @__PURE__ */ o.jsx("span", { className: "text-sm", children: "Building new version..." })
    ] }),
    /* @__PURE__ */ o.jsx("span", { className: "text-xs", children: s ? "To see the new version, reload the page now." : "A new version of the developer portal will be available soon." }),
    /* @__PURE__ */ o.jsx(
      Pr,
      {
        variant: "outline",
        size: "sm",
        className: "w-full",
        onClick: () => {
          window.location.reload();
        },
        children: "Reload"
      }
    )
  ] });
}, mi = () => {
  const r = bt(), e = xe(r.pathname);
  ae(() => {
    const t = e.current !== r.pathname, s = r.hash !== "";
    t && !s && window.scrollTo(0, 0), e.current = r.pathname;
  }, [r.pathname, r.hash]);
}, pi = ({
  icon: r
}) => typeof r == "string" ? /* @__PURE__ */ o.jsx(
  "img",
  {
    src: `https://cdn.simpleicons.org/${r}/000000/ffffff`,
    className: "size-5",
    alt: r
  }
) : r, gi = (r) => /^https?:/.test(r), vi = () => {
  var t;
  const { page: r } = no(), e = r == null ? void 0 : r.footer;
  return e ? /* @__PURE__ */ o.jsx("footer", { className: "border-t bg-background", children: /* @__PURE__ */ o.jsxs("div", { className: "mx-auto max-w-screen-2xl px-4 lg:px-8 py-8 pt-20", children: [
    /* @__PURE__ */ o.jsxs(
      "div",
      {
        className: q("flex flex-row gap-8", {
          "justify-center": !e.position || e.position === "center",
          "justify-start": e.position === "start",
          "justify-end": e.position === "end"
        }),
        children: [
          /* @__PURE__ */ o.jsx(Q, { name: "footer-before" }),
          e.columns && /* @__PURE__ */ o.jsx(
            "div",
            {
              className: "w-full md:max-w-screen-md grid grid-cols-[1fr_1fr] gap-8 md:grid-cols-[repeat(var(--columns),minmax(0,1fr))]",
              style: { "--columns": e.columns.length },
              children: e.columns.map((s) => /* @__PURE__ */ o.jsxs(
                "div",
                {
                  className: q({
                    "justify-self-center": !s.position || s.position === "center",
                    "justify-self-start": s.position === "start",
                    "justify-self-end": s.position === "end"
                  }),
                  children: [
                    /* @__PURE__ */ o.jsx("span", { className: "text-sm font-semibold", children: s.title }),
                    /* @__PURE__ */ o.jsx("ul", { className: "mt-4 space-y-2", children: s.links.map((n, a) => {
                      const i = "flex flex-row gap-1 items-center text-sm text-muted-foreground hover:text-accent-foreground";
                      return /* @__PURE__ */ o.jsx("li", { children: gi(n.href) ? /* @__PURE__ */ o.jsxs(
                        "a",
                        {
                          href: n.href,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className: i,
                          children: [
                            /* @__PURE__ */ o.jsx("span", { children: n.label }),
                            /* @__PURE__ */ o.jsx(cn, { size: 12 })
                          ]
                        }
                      ) : /* @__PURE__ */ o.jsx(
                        gn,
                        {
                          to: n.href + a,
                          className: i,
                          children: /* @__PURE__ */ o.jsx("span", { children: n.label })
                        }
                      ) }, n.href + a);
                    }) })
                  ]
                },
                s.title
              ))
            }
          ),
          /* @__PURE__ */ o.jsx(Q, { name: "footer-after" })
        ]
      }
    ),
    /* @__PURE__ */ o.jsxs(
      "div",
      {
        className: q(
          "flex items-center justify-between",
          e.columns && "border-t mt-8 pt-8"
        ),
        children: [
          e.logo && /* @__PURE__ */ o.jsxs(o.Fragment, { children: [
            /* @__PURE__ */ o.jsx(
              "img",
              {
                src: e.logo.src.light,
                alt: e.logo.alt,
                className: "w-8 dark:hidden",
                style: { width: e.logo.width }
              }
            ),
            /* @__PURE__ */ o.jsx(
              "img",
              {
                src: e.logo.src.dark,
                alt: e.logo.alt,
                className: "w-8 hidden dark:block",
                style: { width: e.logo.width }
              }
            )
          ] }),
          e.copyright && /* @__PURE__ */ o.jsx("p", { className: "text-sm text-muted-foreground", children: e.copyright }),
          /* @__PURE__ */ o.jsx("div", { className: "flex items-center gap-2", children: (t = e.social) == null ? void 0 : t.map((s) => /* @__PURE__ */ o.jsxs(
            "a",
            {
              href: s.href,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "w-auto gap-2 flex text-muted-foreground hover:text-accent-foreground",
              children: [
                /* @__PURE__ */ o.jsx(pi, { icon: s.icon }),
                s.label
              ]
            },
            s.href
          )) })
        ]
      }
    )
  ] }) }) : null;
};
function yi({
  className: r,
  ...e
}) {
  return /* @__PURE__ */ o.jsx(
    "div",
    {
      className: q("animate-pulse rounded-md bg-muted", r),
      ...e
    }
  );
}
const ur = {
  info: "bg-blue-500",
  note: "bg-gray-500",
  tip: "bg-green-600",
  caution: "bg-orange-500",
  danger: "bg-rose-500"
}, xi = () => {
  const { page: r } = ne(), [e, t] = Ee(!0);
  if (!(r != null && r.banner) || !e)
    return /* @__PURE__ */ o.jsx("style", { children: ":root { --banner-height: 0px; }" });
  const s = r.banner.color && r.banner.color in ur ? ur[r.banner.color] : r.banner.color ? void 0 : "bg-primary", n = s ? {} : { backgroundColor: r.banner.color };
  return /* @__PURE__ */ o.jsxs(
    "div",
    {
      className: q(
        "relative text-primary-foreground text-sm font-medium px-4 py-2 flex gap-2 items-center",
        s
      ),
      "data-pagefind-ignore": "all",
      style: n,
      children: [
        /* @__PURE__ */ o.jsx("div", { className: "w-full", children: r.banner.message }),
        r.banner.dismissible && /* @__PURE__ */ o.jsx(
          "button",
          {
            type: "button",
            className: "md:absolute md:right-4 -m-1.5 p-1.5 hover:bg-accent-foreground/10 rounded-md",
            onClick: () => t(!1),
            children: /* @__PURE__ */ o.jsx(dn, { size: 16 })
          }
        )
      ]
    }
  );
}, Gr = (r) => /* @__PURE__ */ o.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 132 100",
    fill: "none",
    ...r,
    children: [
      /* @__PURE__ */ o.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M80.092 2.963A4.66 4.66 0 0 1 84.449 0h34.049c6.325 0 10.835 6.135 8.948 12.172L116.653 46.71a4.688 4.688 0 0 1-4.474 3.29H75c-5.178 0-7.813 4.687-9.375 9.374-1.288 3.864-11.07 28.963-14.467 37.662A4.66 4.66 0 0 1 46.801 100H12.75c-6.324 0-10.834-6.134-8.947-12.171l10.793-34.54A4.688 4.688 0 0 1 19.071 50H56.25c5.178 0 7.813-4.687 9.375-9.375 1.288-3.864 11.07-28.962 14.467-37.662Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ o.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M83.54 57.813a7.813 7.813 0 0 0-7.316 5.07L63.888 95.777c-.766 2.043.744 4.222 2.926 4.222h36.828c5.211 0 9.875-3.232 11.704-8.11l8.821-23.522c1.915-5.107-1.861-10.555-7.315-10.555H83.539ZM29.17 0a12.5 12.5 0 0 0-11.704 8.111l-8.82 23.521c-1.915 5.107 1.86 10.556 7.315 10.556h33.312a7.813 7.813 0 0 0 7.316-5.07L68.924 4.223C69.691 2.18 68.18 0 65.998 0H29.17Z"
        }
      )
    ]
  }
);
Gr.displayName = "ZudokuLogo";
const Jr = ({ className: r }) => /* @__PURE__ */ o.jsxs(
  "a",
  {
    href: "https://zudoku.dev",
    target: "_blank",
    rel: "noopener noreferrer",
    className: q(
      "flex justify-between items-center w-full border border-transparent hover:border-border rounded-full hover:shadow-sm h-7 px-3 text-nowrap hover:bg-muted/80 transition-all",
      r
    ),
    children: [
      /* @__PURE__ */ o.jsxs("div", { className: "opacity-70 hover:opacity-100 transition-opacity gap-1.5 text-[11px] font-medium rounded-full h-7 flex items-center text-nowrap", children: [
        /* @__PURE__ */ o.jsx(Gr, { className: "w-3.5 h-3.5 dark:fill-white" }),
        "powered by ",
        "Zudoku"
      ] }),
      /* @__PURE__ */ o.jsx("div", { className: "text-xs font-medium opacity-70 hover:text-foreground transition-colors cursor-pointer", children: /* @__PURE__ */ o.jsx(un, { size: 12, absoluteStrokeWidth: !0, strokeWidth: 1.5 }) })
    ]
  }
);
function _i() {
  const r = navigator.userAgent.toLowerCase();
  if (r.includes("win")) return "Windows";
  if (r.includes("mac")) return "macOS";
  if (r.includes("linux")) return "Linux";
}
const Xr = ({ className: r }) => {
  const e = ne(), [t, s] = Ee(!1), n = ye(() => s(!1), []);
  ae(() => {
    if (t)
      return;
    function i(c) {
      c.key === "k" && (c.metaKey || c.ctrlKey) && (c.preventDefault(), s(!0));
    }
    return window.addEventListener("keydown", i), () => {
      window.removeEventListener("keydown", i);
    };
  }, [t, s]);
  const a = e.plugins.find(Tn);
  return a ? /* @__PURE__ */ o.jsxs("div", { className: r, children: [
    /* @__PURE__ */ o.jsxs(
      "button",
      {
        type: "button",
        onClick: () => s(!0),
        className: "flex items-center border border-input hover:bg-accent hover:text-accent-foreground p-4 relative h-8 justify-start rounded-lg bg-background text-sm text-muted-foreground shadow-none w-full sm:w-72",
        children: [
          /* @__PURE__ */ o.jsxs("div", { className: "flex items-center gap-2 flex-grow", children: [
            /* @__PURE__ */ o.jsx(ln, { size: 14 }),
            "Search"
          ] }),
          /* @__PURE__ */ o.jsx(kt, { children: /* @__PURE__ */ o.jsx(bi, {}) })
        ]
      }
    ),
    /* @__PURE__ */ o.jsx(Lt, { fallback: null, children: a.renderSearch({
      isOpen: t,
      onClose: n
    }) })
  ] }) : null;
}, bi = () => {
  const r = _i();
  return /* @__PURE__ */ o.jsxs("kbd", { className: "absolute right-1.5 hidden h-5 select-none items-center gap-1 rounded-sm border bg-muted px-1.5 font-mono text-[11px] font-medium opacity-100 sm:flex", children: [
    r === "macOS" ? "⌘" : "Ctrl",
    "+K"
  ] });
}, es = () => {
  const { resolvedTheme: r, setTheme: e } = jr();
  return /* @__PURE__ */ o.jsx(kt, { fallback: /* @__PURE__ */ o.jsx(Pt, { variant: "ghost", size: "icon" }), children: /* @__PURE__ */ o.jsxs(
    "button",
    {
      type: "button",
      className: "flex rounded-full border p-0.5 gap-0.5 group",
      onClick: () => e(r === "dark" ? "light" : "dark"),
      "aria-label": r === "dark" ? "Switch to light mode" : "Switch to dark mode",
      children: [
        /* @__PURE__ */ o.jsx(
          "div",
          {
            className: q(
              "border border-transparent rounded-full p-0.5 [&>svg>circle]:transition-colors [&>svg>path]:transition-transform transition-all [&>svg>path]:duration-200 [&>svg>circle]:duration-500 [&>svg>circle]:fill-transparent",
              r === "light" && "border-border bg-muted",
              r === "dark" && "group-hover:[&>svg>path]:scale-110 group-hover:[&>svg>path]:-translate-x-[1px] group-hover:[&>svg>path]:-translate-y-[1px] group-hover:rotate-[15deg] "
            ),
            children: /* @__PURE__ */ o.jsx(fn, { size: 16 })
          }
        ),
        /* @__PURE__ */ o.jsx(
          "div",
          {
            className: q(
              "border border-transparent rounded-full p-0.5 transition-transform transform-gpu duration-500",
              r === "dark" && "border-border bg-muted [&>svg>path]:fill-white [&>svg>path]:stroke-transparent",
              r === "light" && "group-hover:rotate-[-10deg] [&>svg>path]:stroke-currentColor"
            ),
            children: /* @__PURE__ */ o.jsx(hn, { size: 16 })
          }
        )
      ]
    }
  ) });
};
function _t() {
  return _t = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var s in t) ({}).hasOwnProperty.call(t, s) && (r[s] = t[s]);
    }
    return r;
  }, _t.apply(null, arguments);
}
var dt = { exports: {} }, A = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lr;
function wi() {
  if (lr) return A;
  lr = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, t = r ? Symbol.for("react.portal") : 60106, s = r ? Symbol.for("react.fragment") : 60107, n = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, i = r ? Symbol.for("react.provider") : 60109, c = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, d = r ? Symbol.for("react.concurrent_mode") : 60111, f = r ? Symbol.for("react.forward_ref") : 60112, x = r ? Symbol.for("react.suspense") : 60113, w = r ? Symbol.for("react.suspense_list") : 60120, C = r ? Symbol.for("react.memo") : 60115, k = r ? Symbol.for("react.lazy") : 60116, j = r ? Symbol.for("react.block") : 60121, M = r ? Symbol.for("react.fundamental") : 60117, $ = r ? Symbol.for("react.responder") : 60118, D = r ? Symbol.for("react.scope") : 60119;
  function N(h) {
    if (typeof h == "object" && h !== null) {
      var R = h.$$typeof;
      switch (R) {
        case e:
          switch (h = h.type, h) {
            case u:
            case d:
            case s:
            case a:
            case n:
            case x:
              return h;
            default:
              switch (h = h && h.$$typeof, h) {
                case c:
                case f:
                case k:
                case C:
                case i:
                  return h;
                default:
                  return R;
              }
          }
        case t:
          return R;
      }
    }
  }
  function O(h) {
    return N(h) === d;
  }
  return A.AsyncMode = u, A.ConcurrentMode = d, A.ContextConsumer = c, A.ContextProvider = i, A.Element = e, A.ForwardRef = f, A.Fragment = s, A.Lazy = k, A.Memo = C, A.Portal = t, A.Profiler = a, A.StrictMode = n, A.Suspense = x, A.isAsyncMode = function(h) {
    return O(h) || N(h) === u;
  }, A.isConcurrentMode = O, A.isContextConsumer = function(h) {
    return N(h) === c;
  }, A.isContextProvider = function(h) {
    return N(h) === i;
  }, A.isElement = function(h) {
    return typeof h == "object" && h !== null && h.$$typeof === e;
  }, A.isForwardRef = function(h) {
    return N(h) === f;
  }, A.isFragment = function(h) {
    return N(h) === s;
  }, A.isLazy = function(h) {
    return N(h) === k;
  }, A.isMemo = function(h) {
    return N(h) === C;
  }, A.isPortal = function(h) {
    return N(h) === t;
  }, A.isProfiler = function(h) {
    return N(h) === a;
  }, A.isStrictMode = function(h) {
    return N(h) === n;
  }, A.isSuspense = function(h) {
    return N(h) === x;
  }, A.isValidElementType = function(h) {
    return typeof h == "string" || typeof h == "function" || h === s || h === d || h === a || h === n || h === x || h === w || typeof h == "object" && h !== null && (h.$$typeof === k || h.$$typeof === C || h.$$typeof === i || h.$$typeof === c || h.$$typeof === f || h.$$typeof === M || h.$$typeof === $ || h.$$typeof === D || h.$$typeof === j);
  }, A.typeOf = N, A;
}
var P = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fr;
function ki() {
  return fr || (fr = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, t = r ? Symbol.for("react.portal") : 60106, s = r ? Symbol.for("react.fragment") : 60107, n = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, i = r ? Symbol.for("react.provider") : 60109, c = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, d = r ? Symbol.for("react.concurrent_mode") : 60111, f = r ? Symbol.for("react.forward_ref") : 60112, x = r ? Symbol.for("react.suspense") : 60113, w = r ? Symbol.for("react.suspense_list") : 60120, C = r ? Symbol.for("react.memo") : 60115, k = r ? Symbol.for("react.lazy") : 60116, j = r ? Symbol.for("react.block") : 60121, M = r ? Symbol.for("react.fundamental") : 60117, $ = r ? Symbol.for("react.responder") : 60118, D = r ? Symbol.for("react.scope") : 60119;
    function N(v) {
      return typeof v == "string" || typeof v == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      v === s || v === d || v === a || v === n || v === x || v === w || typeof v == "object" && v !== null && (v.$$typeof === k || v.$$typeof === C || v.$$typeof === i || v.$$typeof === c || v.$$typeof === f || v.$$typeof === M || v.$$typeof === $ || v.$$typeof === D || v.$$typeof === j);
    }
    function O(v) {
      if (typeof v == "object" && v !== null) {
        var St = v.$$typeof;
        switch (St) {
          case e:
            var at = v.type;
            switch (at) {
              case u:
              case d:
              case s:
              case a:
              case n:
              case x:
                return at;
              default:
                var Qt = at && at.$$typeof;
                switch (Qt) {
                  case c:
                  case f:
                  case k:
                  case C:
                  case i:
                    return Qt;
                  default:
                    return St;
                }
            }
          case t:
            return St;
        }
      }
    }
    var h = u, R = d, W = c, Y = i, oe = e, me = f, Tt = s, je = k, hs = C, ms = t, ps = a, gs = n, vs = x, Vt = !1;
    function ys(v) {
      return Vt || (Vt = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Ut(v) || O(v) === u;
    }
    function Ut(v) {
      return O(v) === d;
    }
    function xs(v) {
      return O(v) === c;
    }
    function _s(v) {
      return O(v) === i;
    }
    function bs(v) {
      return typeof v == "object" && v !== null && v.$$typeof === e;
    }
    function ws(v) {
      return O(v) === f;
    }
    function ks(v) {
      return O(v) === s;
    }
    function js(v) {
      return O(v) === k;
    }
    function Ts(v) {
      return O(v) === C;
    }
    function Ss(v) {
      return O(v) === t;
    }
    function Cs(v) {
      return O(v) === a;
    }
    function Ns(v) {
      return O(v) === n;
    }
    function Es(v) {
      return O(v) === x;
    }
    P.AsyncMode = h, P.ConcurrentMode = R, P.ContextConsumer = W, P.ContextProvider = Y, P.Element = oe, P.ForwardRef = me, P.Fragment = Tt, P.Lazy = je, P.Memo = hs, P.Portal = ms, P.Profiler = ps, P.StrictMode = gs, P.Suspense = vs, P.isAsyncMode = ys, P.isConcurrentMode = Ut, P.isContextConsumer = xs, P.isContextProvider = _s, P.isElement = bs, P.isForwardRef = ws, P.isFragment = ks, P.isLazy = js, P.isMemo = Ts, P.isPortal = Ss, P.isProfiler = Cs, P.isStrictMode = Ns, P.isSuspense = Es, P.isValidElementType = N, P.typeOf = O;
  }()), P;
}
var hr;
function ji() {
  return hr || (hr = 1, process.env.NODE_ENV === "production" ? dt.exports = wi() : dt.exports = ki()), dt.exports;
}
var Ot, mr;
function Ti() {
  if (mr) return Ot;
  mr = 1;
  var r = ji(), e = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, t = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, s = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, n = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[r.ForwardRef] = s, a[r.Memo] = n;
  function i(k) {
    return r.isMemo(k) ? n : a[k.$$typeof] || e;
  }
  var c = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, f = Object.getOwnPropertyDescriptor, x = Object.getPrototypeOf, w = Object.prototype;
  function C(k, j, M) {
    if (typeof j != "string") {
      if (w) {
        var $ = x(j);
        $ && $ !== w && C(k, $, M);
      }
      var D = u(j);
      d && (D = D.concat(d(j)));
      for (var N = i(k), O = i(j), h = 0; h < D.length; ++h) {
        var R = D[h];
        if (!t[R] && !(M && M[R]) && !(O && O[R]) && !(N && N[R])) {
          var W = f(j, R);
          try {
            c(k, R, W);
          } catch {
          }
        }
      }
    }
    return k;
  }
  return Ot = C, Ot;
}
Ti();
var ts = function(e, t, s) {
  return e = e <= s ? e : s, e = e >= t ? e : t, e;
}, Si = function() {
  var e = !1, t = [], s = function() {
    e = !0;
    var c = t.shift();
    if (c)
      return c(s);
    e = !1;
  }, n = function() {
    e = !1, t = [];
  }, a = function(c) {
    t.push(c), !e && t.length === 1 && s();
  };
  return {
    clear: n,
    enqueue: a
  };
}, Ci = function() {
  var e, t = function() {
    e && window.cancelAnimationFrame(e);
  }, s = function(a, i) {
    var c, u, d = function(x) {
      if (u = u || x, c = x - u, c > i) {
        a();
        return;
      }
      e = window.requestAnimationFrame(d);
    };
    e = window.requestAnimationFrame(d);
  };
  return {
    cancel: t,
    schedule: s
  };
}, Ni = function(e) {
  var t = 0;
  return e >= 0 && e < 0.2 ? t = 0.1 : e >= 0.2 && e < 0.5 ? t = 0.04 : e >= 0.5 && e < 0.8 ? t = 0.02 : e >= 0.8 && e < 0.99 && (t = 5e-3), ts(e + t, 0, 0.994);
}, pr = function(e) {
  ae(e, []);
}, Ei = function(e) {
  return ++e % 1e6;
}, Oi = function() {
  var e = Ee(0), t = e[1];
  return ye(function() {
    return t(Ei);
  }, []);
}, Ai = function(e) {
  e === void 0 && (e = {});
  var t = Oi(), s = xe(_t({}, e)), n = ye(function() {
    return s.current;
  }, []), a = ye(function(i) {
    i && (Object.assign(s.current, i), t());
  }, []);
  return [n, a];
}, Pi = function() {
  var e = xe(!0);
  return e.current ? (e.current = !1, !0) : e.current;
}, gr = function(e, t) {
  var s = Pi();
  ae(function() {
    if (!s)
      return e();
  }, t);
}, rs = function() {
}, vr = {
  isFinished: !0,
  progress: 0,
  sideEffect: rs
}, Ri = function(e) {
  var t = e === void 0 ? {} : e, s = t.animationDuration, n = s === void 0 ? 200 : s, a = t.incrementDuration, i = a === void 0 ? 800 : a, c = t.isAnimating, u = c === void 0 ? !1 : c, d = t.minimum, f = d === void 0 ? 0.08 : d, x = Ai(vr), w = x[0], C = x[1], k = xe(null), j = xe(null);
  pr(function() {
    k.current = Si(), j.current = Ci();
  });
  var M = ye(function() {
    var R, W;
    (R = j.current) == null || R.cancel(), (W = k.current) == null || W.clear();
  }, []), $ = ye(function(R) {
    var W;
    if (R = ts(R, f, 1), R === 1) {
      var Y, oe;
      M(), (Y = k.current) == null || Y.enqueue(function(me) {
        C({
          progress: R,
          sideEffect: function() {
            var je;
            return (je = j.current) == null ? void 0 : je.schedule(me, n);
          }
        });
      }), (oe = k.current) == null || oe.enqueue(function() {
        C({
          isFinished: !0,
          sideEffect: M
        });
      });
      return;
    }
    (W = k.current) == null || W.enqueue(function(me) {
      C({
        isFinished: !1,
        progress: R,
        sideEffect: function() {
          var je;
          return (je = j.current) == null ? void 0 : je.schedule(me, n);
        }
      });
    });
  }, [n, M, f, k, C, j]), D = ye(function() {
    $(Ni(w().progress));
  }, [w, $]), N = ye(function() {
    var R = function() {
      var Y;
      D(), (Y = k.current) == null || Y.enqueue(function(oe) {
        var me;
        (me = j.current) == null || me.schedule(function() {
          R(), oe();
        }, i);
      });
    };
    R();
  }, [i, k, j, D]), O = xe(rs), h = w().sideEffect;
  return ae(function() {
    O.current = D;
  }), pr(function() {
    return u && N(), M;
  }), gr(function() {
    w().sideEffect();
  }, [w, h]), gr(function() {
    u ? C(_t({}, vr, {
      sideEffect: N
    })) : $(1);
  }, [u, $, C, N]), {
    animationDuration: n,
    isFinished: w().isFinished,
    progress: w().progress
  };
};
const ss = (r) => (e) => e.display === "hide" ? !1 : e.display === "auth" && r || e.display === "anon" && !r || !e.display || e.display === "always", ns = () => {
  const e = wt().state === "loading", [t, s] = Ee(!1);
  ae(() => {
    const i = setTimeout(() => s(e), 100);
    return () => clearTimeout(i);
  }, [e]);
  const { isFinished: n, progress: a } = Ri({ isAnimating: t });
  return /* @__PURE__ */ o.jsx(
    "div",
    {
      className: "absolute w-0 left-0 right-0 bottom-[-1px] h-[2px] bg-primary transition-all duration-300 ease-in-out",
      style: {
        opacity: n ? 0 : 1,
        width: n ? 0 : `${a * 100}%`
      }
    }
  );
}, Mi = () => {
  const { topNavigation: r } = ne(), { isAuthenticated: e } = Be(), t = r.filter(ss(e));
  return t.length === 0 ? /* @__PURE__ */ o.jsx("style", { children: ":root { --top-nav-height: 0px; }" }) : /* @__PURE__ */ o.jsxs(Lt, { children: [
    /* @__PURE__ */ o.jsxs("div", { className: "items-center justify-between px-8 h-[--top-nav-height] hidden lg:flex text-sm relative", children: [
      /* @__PURE__ */ o.jsx("nav", { className: "text-sm", children: /* @__PURE__ */ o.jsx("ul", { className: "flex flex-row items-center gap-8", children: t.map((s) => /* @__PURE__ */ o.jsx("li", { children: /* @__PURE__ */ o.jsx(as, { ...s }) }, s.id)) }) }),
      /* @__PURE__ */ o.jsx(Q, { name: "top-navigation-side" })
    ] }),
    /* @__PURE__ */ o.jsx(ns, {})
  ] });
}, as = ({
  id: r,
  label: e,
  default: t
}) => {
  var d;
  const { sidebars: s } = ne(), n = s[r], a = Or(), i = !!wt().location, c = ((d = a.topNavItem) == null ? void 0 : d.id) === r && !i, u = t ?? (n ? Us(n, (f) => {
    if (f.type === "doc") return Pe(f.id);
  }) : Pe(r)) ?? Pe(r);
  return (
    // We don't use isActive here because it has to be inside the sidebar,
    // the top nav id doesn't necessarily start with the sidebar id
    /* @__PURE__ */ o.jsx(
      Zs,
      {
        className: ({ isPending: f }) => Un(
          "block lg:py-3.5 font-medium -mb-px",
          c || f ? "border-primary text-foreground" : "border-transparent text-foreground/75 hover:text-foreground hover:border-accent-foreground/25"
        ),
        to: u,
        children: e
      }
    )
  );
}, Ii = () => {
  var a;
  const { topNavigation: r, options: e } = ne(), { isAuthenticated: t } = Be(), [s, n] = Ee(!1);
  return /* @__PURE__ */ o.jsxs(
    Bn,
    {
      direction: "right",
      open: s,
      onOpenChange: (i) => n(i),
      children: [
        /* @__PURE__ */ o.jsxs("div", { className: "flex lg:hidden justify-self-end", children: [
          /* @__PURE__ */ o.jsx(Vn, { className: "lg:hidden", children: /* @__PURE__ */ o.jsx(mn, { size: 22 }) }),
          /* @__PURE__ */ o.jsx(ns, {})
        ] }),
        /* @__PURE__ */ o.jsx(
          $r,
          {
            className: "lg:hidden h-[100dvh] right-0 left-auto w-[320px] rounded-none",
            "aria-describedby": void 0,
            children: /* @__PURE__ */ o.jsxs("div", { className: "p-4 overflow-y-auto overscroll-none h-full flex flex-col justify-between", children: [
              /* @__PURE__ */ o.jsxs("div", { children: [
                /* @__PURE__ */ o.jsx(Zr, { children: /* @__PURE__ */ o.jsx(Dr, { children: "Navigation" }) }),
                /* @__PURE__ */ o.jsx(Xr, { className: "flex p-4" }),
                /* @__PURE__ */ o.jsxs("ul", { className: "flex flex-col items-center gap-4 p-4", children: [
                  /* @__PURE__ */ o.jsx("li", { children: /* @__PURE__ */ o.jsx(es, {}) }),
                  r.filter(ss(t)).map((i) => /* @__PURE__ */ o.jsx("li", { children: /* @__PURE__ */ o.jsx("button", { type: "button", onClick: () => n(!1), children: /* @__PURE__ */ o.jsx(as, { ...i }) }) }, i.label))
                ] })
              ] }),
              ((a = e.page) == null ? void 0 : a.showPoweredBy) !== !1 && /* @__PURE__ */ o.jsx(Jr, { className: "flex-grow-0 justify-center gap-1" })
            ] })
          }
        )
      ]
    }
  );
}, lt = ({ item: r }) => r.children ? /* @__PURE__ */ o.jsxs(Dn, { children: [
  /* @__PURE__ */ o.jsx(zn, { children: r.label }),
  /* @__PURE__ */ o.jsx(Fn, { children: /* @__PURE__ */ o.jsx(qn, { children: r.children.map((e, t) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ o.jsx(lt, { item: e }, t)
  )) }) })
] }, r.label) : /* @__PURE__ */ o.jsx(Ft, { to: r.path ?? "", children: /* @__PURE__ */ o.jsxs(Ln, { className: "flex gap-2", children: [
  r.icon && /* @__PURE__ */ o.jsx(r.icon, { size: 16, strokeWidth: 1, absoluteStrokeWidth: !0 }),
  r.label
] }, r.label) }), is = Mr(function() {
  const e = Be(), { isAuthenticated: t, profile: s, isAuthEnabled: n } = Be(), a = ne(), { page: i, plugins: c } = a, u = c.filter((d) => Sn(d)).flatMap((d) => d.getProfileMenuItems(a)).sort((d) => d.weight ?? 0);
  return /* @__PURE__ */ o.jsxs("header", { className: "sticky lg:top-0 z-10 bg-background/80 backdrop-blur w-full", children: [
    /* @__PURE__ */ o.jsx(xi, {}),
    /* @__PURE__ */ o.jsx("div", { className: "border-b", children: /* @__PURE__ */ o.jsxs("div", { className: "max-w-screen-2xl mx-auto flex relative items-center justify-between px-4 lg:px-8 h-[--top-header-height] border-transparent", children: [
      /* @__PURE__ */ o.jsx("div", { className: "flex", children: /* @__PURE__ */ o.jsx(Ft, { to: "/", children: /* @__PURE__ */ o.jsxs("div", { className: "flex items-center gap-3.5", children: [
        (i == null ? void 0 : i.logo) && /* @__PURE__ */ o.jsxs(o.Fragment, { children: [
          /* @__PURE__ */ o.jsx(
            "img",
            {
              src: /https?:\/\//.test(i.logo.src.light) ? i.logo.src.light : Pe(
                "/",
                i.logo.src.light
              ),
              alt: i.logo.alt ?? i.pageTitle,
              style: { width: i.logo.width },
              className: "h-10 dark:hidden",
              loading: "lazy"
            }
          ),
          /* @__PURE__ */ o.jsx(
            "img",
            {
              src: /https?:\/\//.test(i.logo.src.dark) ? i.logo.src.dark : Pe(
                "/",
                i.logo.src.dark
              ),
              alt: i.logo.alt ?? i.pageTitle,
              style: { width: i.logo.width },
              className: "h-10 hidden dark:block",
              loading: "lazy"
            }
          )
        ] }),
        /* @__PURE__ */ o.jsx("span", { className: "font-bold text-2xl text-foreground/85 tracking-wide", children: i == null ? void 0 : i.pageTitle })
      ] }) }) }),
      /* @__PURE__ */ o.jsx("div", { className: "absolute inset-x-0 justify-center items-center hidden lg:flex w-full pointer-events-none", children: /* @__PURE__ */ o.jsx(Xr, { className: "pointer-events-auto" }) }),
      /* @__PURE__ */ o.jsxs("div", { className: "flex items-center gap-8", children: [
        /* @__PURE__ */ o.jsx(Ii, {}),
        /* @__PURE__ */ o.jsxs("div", { className: "hidden lg:flex items-center justify-self-end text-sm gap-2", children: [
          /* @__PURE__ */ o.jsx(Q, { name: "head-navigation-start" }),
          n && /* @__PURE__ */ o.jsx(
            kt,
            {
              fallback: /* @__PURE__ */ o.jsx(yi, { className: "rounded h-5 w-24 mr-4" }),
              children: t ? Object.values(u).length > 0 && /* @__PURE__ */ o.jsxs(Mn, { modal: !1, children: [
                /* @__PURE__ */ o.jsx(In, { asChild: !0, children: /* @__PURE__ */ o.jsx(Pt, { variant: "ghost", children: s != null && s.name ? `${s.name}` : "My Account" }) }),
                /* @__PURE__ */ o.jsxs(Zn, { className: "w-56", children: [
                  /* @__PURE__ */ o.jsxs($n, { children: [
                    s != null && s.name ? `${s.name}` : "My Account",
                    (s == null ? void 0 : s.email) && /* @__PURE__ */ o.jsx("div", { className: "font-normal text-muted-foreground", children: s.email })
                  ] }),
                  u.filter((d) => d.category === "top").length > 0 && /* @__PURE__ */ o.jsx(Nt, {}),
                  u.filter((d) => d.category === "top").map((d) => /* @__PURE__ */ o.jsx(lt, { item: d }, d.label)),
                  u.filter(
                    (d) => !d.category || d.category === "middle"
                  ).length > 0 && /* @__PURE__ */ o.jsx(Nt, {}),
                  u.filter(
                    (d) => !d.category || d.category === "middle"
                  ).map((d) => /* @__PURE__ */ o.jsx(lt, { item: d }, d.label)),
                  u.filter((d) => d.category === "bottom").length > 0 && /* @__PURE__ */ o.jsx(Nt, {}),
                  u.filter((d) => d.category === "bottom").map((d) => /* @__PURE__ */ o.jsx(lt, { item: d }, d.label))
                ] })
              ] }) : /* @__PURE__ */ o.jsx(Pt, { variant: "ghost", onClick: () => e.login(), children: "Login" })
            }
          ),
          /* @__PURE__ */ o.jsx(Q, { name: "head-navigation-end" }),
          /* @__PURE__ */ o.jsx(es, {})
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ o.jsx("div", { className: "border-b hidden lg:block", children: /* @__PURE__ */ o.jsxs("div", { className: "max-w-screen-2xl mx-auto border-transparent", children: [
      /* @__PURE__ */ o.jsx(Q, { name: "top-navigation-before" }),
      /* @__PURE__ */ o.jsx(Mi, {}),
      /* @__PURE__ */ o.jsx(Q, { name: "top-navigation-after" })
    ] }) })
  ] });
}), os = ({
  shouldScaleBackground: r = !0,
  ...e
}) => /* @__PURE__ */ o.jsx(
  ie.Root,
  {
    shouldScaleBackground: r,
    ...e
  }
);
os.displayName = "Drawer";
const Zi = ie.Trigger, $i = ie.Portal, cs = fe.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ o.jsx(
  ie.Overlay,
  {
    ref: t,
    className: q("fixed inset-0 z-50 bg-black/80", r),
    ...e
  }
));
cs.displayName = ie.Overlay.displayName;
const Di = fe.forwardRef(
  ({ className: r, children: e, hideBar: t = !0, ...s }, n) => /* @__PURE__ */ o.jsxs($i, { children: [
    /* @__PURE__ */ o.jsx(cs, {}),
    /* @__PURE__ */ o.jsxs(
      ie.Content,
      {
        ref: n,
        className: q(
          "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
          r
        ),
        ...s,
        children: [
          !t && /* @__PURE__ */ o.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          e
        ]
      }
    )
  ] })
);
Di.displayName = "DrawerContent";
const zi = fe.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ o.jsx(
  ie.Title,
  {
    ref: t,
    className: q(
      "text-lg font-semibold leading-none tracking-tight",
      r
    ),
    ...e
  }
));
zi.displayName = ie.Title.displayName;
const Fi = fe.forwardRef(({ className: r, ...e }, t) => /* @__PURE__ */ o.jsx(
  ie.Description,
  {
    ref: t,
    className: q("text-sm text-muted-foreground", r),
    ...e
  }
));
Fi.displayName = ie.Description.displayName;
const ds = ({
  children: r,
  className: e
}) => {
  var n;
  const { options: t } = ne(), s = xe(null);
  return ae(() => {
    var i;
    const a = (i = s.current) == null ? void 0 : i.querySelector('[aria-current="page"]');
    vn(a ?? null);
  }, []), /* @__PURE__ */ o.jsxs("div", { className: "grid sticky top-[--header-height] lg:h-[calc(100vh-var(--header-height))] grid-rows-[1fr_min-content] border-r", children: [
    /* @__PURE__ */ o.jsx(
      "nav",
      {
        ref: s,
        className: q(
          "hidden max-w-[calc(var(--side-nav-width)+var(--padding-nav-item))] lg:flex scrollbar flex-col overflow-y-auto shrink-0 text-sm pe-3 ps-4 lg:ps-8",
          "-mx-[--padding-nav-item] pb-[8vh] pt-[--padding-content-top] scroll-pt-2 gap-1",
          // Revert the padding/margin on the first child
          "-mt-2.5",
          e
        ),
        style: {
          maskImage: "linear-gradient(180deg, transparent 1%, rgba(0, 0, 0, 1) 20px, rgba(0, 0, 0, 1) 90%, transparent 99%)"
        },
        children: r
      }
    ),
    /* @__PURE__ */ o.jsx("div", { className: "bg-background border-t p-2 mx-5  gap-2 items-center mt-2 drop-shadow-[0_-3px_1px_rgba(0,0,0,0.015)] hidden lg:[&:has(>_:nth-child(1):last-child)]:flex", children: ((n = t.page) == null ? void 0 : n.showPoweredBy) !== !1 && /* @__PURE__ */ o.jsx(Jr, {}) })
  ] });
};
ds.displayName = "SidebarWrapper";
const qi = ({
  onRequestClose: r,
  sidebar: e
}) => /* @__PURE__ */ o.jsxs(o.Fragment, { children: [
  /* @__PURE__ */ o.jsxs(ds, { children: [
    /* @__PURE__ */ o.jsx(Q, { name: "zudoku-before-navigation" }),
    e.map((t) => /* @__PURE__ */ o.jsx(
      rr,
      {
        item: t
      },
      ("id" in t ? t.id : "") + ("href" in t ? t.href : "") + t.label
    )),
    /* @__PURE__ */ o.jsx(Q, { name: "zudoku-after-navigation" })
  ] }),
  /* @__PURE__ */ o.jsx(
    $r,
    {
      className: "lg:hidden h-[100dvh] left-0 w-[320px] rounded-none",
      "aria-describedby": void 0,
      children: /* @__PURE__ */ o.jsxs("div", { className: "p-4 overflow-y-auto overscroll-none", children: [
        /* @__PURE__ */ o.jsx(Zr, { children: /* @__PURE__ */ o.jsx(Dr, { children: "Sidebar" }) }),
        e.map((t) => /* @__PURE__ */ o.jsx(
          rr,
          {
            item: t,
            onRequestClose: r
          },
          t.label
        ))
      ] })
    }
  )
] }), Li = ({ children: r }) => {
  const [e, t] = Ee(!1), { sidebar: s } = Or(), n = s.length > 0, a = wt().state === "loading";
  return /* @__PURE__ */ o.jsxs(
    os,
    {
      direction: "left",
      open: e,
      onOpenChange: (i) => t(i),
      children: [
        n && /* @__PURE__ */ o.jsx(
          qi,
          {
            onRequestClose: () => t(!1),
            sidebar: s
          }
        ),
        n && /* @__PURE__ */ o.jsx("div", { className: "lg:hidden -mx-4 px-4 py-2 sticky bg-background/80 backdrop-blur z-10 top-0 left-0 right-0 border-b", children: /* @__PURE__ */ o.jsxs(Zi, { className: "flex items-center gap-2 px-4", children: [
          /* @__PURE__ */ o.jsx(pn, { size: 16, strokeWidth: 1.5 }),
          /* @__PURE__ */ o.jsx("span", { className: "text-sm", children: "Menu" })
        ] }) }),
        /* @__PURE__ */ o.jsxs(
          "main",
          {
            "data-pagefind-body": !0,
            className: q(
              "px-4 lg:pe-8 lg:px-8",
              !n && "col-span-full",
              a && "animate-pulse"
            ),
            children: [
              /* @__PURE__ */ o.jsx(Q, { name: "zudoku-before-content" }),
              r,
              /* @__PURE__ */ o.jsx(Q, { name: "zudoku-after-content" })
            ]
          }
        )
      ]
    }
  );
}, Bi = () => /* @__PURE__ */ o.jsx("main", { className: "col-span-full row-span-full grid place-items-center", children: /* @__PURE__ */ o.jsx(Ir, {}) }), Vi = ({ children: r }) => {
  const { meta: e, authentication: t, options: s } = ne(), n = bt();
  return yn(), mi(), ae(() => {
    var a;
    (a = t == null ? void 0 : t.onPageLoad) == null || a.call(t);
  }, [t]), /* @__PURE__ */ o.jsxs(o.Fragment, { children: [
    !1,
    /* @__PURE__ */ o.jsxs(zt, { titleTemplate: e == null ? void 0 : e.title, children: [
      s.canonicalUrlOrigin && /* @__PURE__ */ o.jsx(
        "link",
        {
          rel: "canonical",
          href: Pe(
            s.canonicalUrlOrigin,
            s.basePath,
            n.pathname
          )
        }
      ),
      (e == null ? void 0 : e.description) && /* @__PURE__ */ o.jsx("meta", { name: "description", content: e.description }),
      (e == null ? void 0 : e.favicon) && /* @__PURE__ */ o.jsx("link", { rel: "icon", href: e.favicon })
    ] }),
    /* @__PURE__ */ o.jsx(Q, { name: "layout-before-head" }),
    /* @__PURE__ */ o.jsx(is, {}),
    /* @__PURE__ */ o.jsx(Q, { name: "layout-after-head" }),
    /* @__PURE__ */ o.jsx(
      "div",
      {
        className: q(
          "grid max-w-screen-2xl w-full lg:mx-auto",
          "has-[:only-child]:grid-rows-1 grid-rows-[0_min-content_1fr] lg:grid-rows-[min-content_1fr]",
          "grid-cols-1 lg:grid-cols-[var(--side-nav-width)_1fr]"
        ),
        children: /* @__PURE__ */ o.jsx(Lt, { fallback: /* @__PURE__ */ o.jsx(Bi, {}), children: /* @__PURE__ */ o.jsx(Li, { children: r ?? /* @__PURE__ */ o.jsx(Tr, {}) }) })
      }
    ),
    /* @__PURE__ */ o.jsx(vi, {})
  ] });
}, Ui = ({
  title: r = "An error occurred",
  message: e,
  category: t
}) => /* @__PURE__ */ o.jsxs("div", { className: _n + " h-full pt-[--padding-content-top]", children: [
  t && /* @__PURE__ */ o.jsx(jn, { children: t }),
  r && /* @__PURE__ */ o.jsx(xn, { level: 1, className: "flex gap-3.5 items-center", children: r }),
  /* @__PURE__ */ o.jsx("p", { children: e })
] }), Qi = (r) => {
  switch (r) {
    case 400:
      return {
        title: "Bad Request",
        message: "The request could not be understood by the server due to malformed syntax."
      };
    case 403:
      return {
        title: "Forbidden",
        message: "You don't have permission to access this resource."
      };
    case 404:
      return {
        title: "Not Found",
        message: "The requested resource could not be found."
      };
    case 405:
      return {
        title: "Method Not Allowed",
        message: "The request method is not supported for the requested resource."
      };
    case 414:
      return {
        title: "Request URI Too Large",
        message: "The request URI is too large."
      };
    case 416:
      return {
        title: "Range Not Satisfiable",
        message: "The server cannot satisfy the request range."
      };
    case 500:
      return {
        title: "Internal Server Error",
        message: "An unexpected error occurred while processing your request."
      };
    case 501:
      return {
        title: "Not Implemented",
        message: "The server does not support the functionality required to fulfill the request."
      };
    case 502:
      return {
        title: "Bad Gateway",
        message: "The server received an invalid response from the upstream server."
      };
    case 503:
      return {
        title: "Service Unavailable",
        message: "The server is temporarily unable to handle the request."
      };
    case 504:
      return {
        title: "Gateway Timeout",
        message: "The server did not receive a timely response from the upstream server."
      };
    default:
      return {
        title: "An error occurred",
        message: "Something went wrong while processing your request."
      };
  }
}, Hi = ({ statusCode: r, message: e }) => {
  const t = Qi(r);
  return /* @__PURE__ */ o.jsx(
    Ui,
    {
      title: t.title,
      message: e ?? t.message,
      category: r
    }
  );
}, Wi = qt(null), At = {
  didCatch: !1,
  error: null
};
class Yi extends rn {
  constructor(e) {
    super(e), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = At;
  }
  static getDerivedStateFromError(e) {
    return {
      didCatch: !0,
      error: e
    };
  }
  resetErrorBoundary() {
    const {
      error: e
    } = this.state;
    if (e !== null) {
      for (var t, s, n = arguments.length, a = new Array(n), i = 0; i < n; i++)
        a[i] = arguments[i];
      (t = (s = this.props).onReset) === null || t === void 0 || t.call(s, {
        args: a,
        reason: "imperative-api"
      }), this.setState(At);
    }
  }
  componentDidCatch(e, t) {
    var s, n;
    (s = (n = this.props).onError) === null || s === void 0 || s.call(n, e, t);
  }
  componentDidUpdate(e, t) {
    const {
      didCatch: s
    } = this.state, {
      resetKeys: n
    } = this.props;
    if (s && t.error !== null && Ki(e.resetKeys, n)) {
      var a, i;
      (a = (i = this.props).onReset) === null || a === void 0 || a.call(i, {
        next: n,
        prev: e.resetKeys,
        reason: "keys"
      }), this.setState(At);
    }
  }
  render() {
    const {
      children: e,
      fallbackRender: t,
      FallbackComponent: s,
      fallback: n
    } = this.props, {
      didCatch: a,
      error: i
    } = this.state;
    let c = e;
    if (a) {
      const u = {
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof t == "function")
        c = t(u);
      else if (s)
        c = tr(s, u);
      else if (n !== void 0)
        c = n;
      else
        throw i;
    }
    return tr(Wi.Provider, {
      value: {
        didCatch: a,
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, c);
  }
}
function Ki() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return r.length !== e.length || r.some((t, s) => !Object.is(t, e[s]));
}
let Gi = () => ({
  emit(r, ...e) {
    for (let t = this.events[r] || [], s = 0, n = t.length; s < n; s++)
      t[s](...e);
  },
  events: {},
  on(r, e) {
    var t;
    return ((t = this.events)[r] || (t[r] = [])).push(e), () => {
      var s;
      this.events[r] = (s = this.events[r]) == null ? void 0 : s.filter((n) => e !== n);
    };
  }
});
class Ji {
  constructor(e, t) {
    B(this, "plugins");
    B(this, "sidebars");
    B(this, "topNavigation");
    B(this, "meta");
    B(this, "page");
    B(this, "authentication");
    B(this, "navigationPlugins");
    B(this, "emitter", Gi());
    B(this, "initialize", async () => {
      await Promise.all(
        this.plugins.filter(En).map((e) => {
          var t;
          return (t = e.initialize) == null ? void 0 : t.call(e, this);
        })
      );
    });
    B(this, "getApiIdentities", async () => (await Promise.all(
      this.plugins.filter(On).map((t) => t.getIdentities(this))
    )).flat());
    B(this, "emitEvent", (e, ...t) => this.emitter.emit(e, ...t));
    B(this, "getPluginSidebar", async (e) => (await Promise.all(
      this.navigationPlugins.map(
        (s) => {
          var n;
          return (n = s.getSidebar) == null ? void 0 : n.call(s, Hs(e), this);
        }
      )
    )).flatMap((s) => s ?? []));
    B(this, "signRequest", async (e) => {
      if (!this.authentication)
        throw new Error("No authentication provider configured");
      return await this.authentication.signRequest(e);
    });
    this.options = e, this.queryClient = t, this.plugins = e.plugins ?? [], this.topNavigation = e.topNavigation ?? [], this.sidebars = e.sidebars ?? {}, this.navigationPlugins = this.plugins.filter(Cn), this.authentication = e.authentication, this.meta = e.metadata, this.page = e.page, this.plugins.forEach((s) => {
      Nn(s) && Rn(s.events).forEach(([n, a]) => {
        this.emitter.on(n, a);
      });
    }), Qs.subscribe((s, n) => {
      this.emitEvent("auth", {
        prev: n,
        next: s
      });
    });
  }
  addEventListener(e, t) {
    return this.emitter.on(e, t);
  }
}
function Xi({ error: r, resetErrorBoundary: e }) {
  return /* @__PURE__ */ o.jsx(Ar, { error: r });
}
const ut = globalThis;
(!ut.requestIdleCallback || !ut.cancelIdleCallback) && (ut.requestIdleCallback = (r) => setTimeout(r, 1), ut.cancelIdleCallback = clearTimeout);
const us = {
  Header: is
}, eo = qt(us), to = eo.Provider, ro = () => {
  const r = bt(), e = ne(), t = xe(void 0);
  return ae(() => {
    e.emitEvent("location", {
      from: t.current,
      to: r
    }), t.current = r;
  }, [e, r]), null;
}, so = ({
  children: r,
  context: e
}) => (Ws({
  queryFn: async () => (await e.initialize(), !0),
  queryKey: ["zudoku-initialize"]
}), /* @__PURE__ */ o.jsx(Ys.Provider, { value: e, children: r }));
let yr;
const ls = Mr(
  ({ children: r, ...e }) => {
    var w, C;
    const t = Ct(
      () => ({ ...us, ...e.overrides }),
      [e.overrides]
    ), s = bt(), n = Ct(() => {
      var j;
      return {
        ...(e.plugins ?? []).filter(An).flatMap(
          (M) => M.getMdxComponents ? [M.getMdxComponents()] : []
        ).reduce(
          (M, $) => ({ ...M, ...$ }),
          {}
        ),
        ...bn,
        ...(j = e.mdx) == null ? void 0 : j.components
      };
    }, [(w = e.mdx) == null ? void 0 : w.components, e.plugins]), { stagger: a } = sn(Mt), [i, c] = Ee(!1), u = Ct(
      () => i ? { stagger: !0 } : { stagger: a },
      [a, i]
    ), d = wt(), f = Nr();
    ae(() => {
      i || c(!0);
    }, [i, d.location]), yr ?? (yr = new Ji(e, f));
    const x = (C = e.plugins) == null ? void 0 : C.flatMap(
      (k) => {
        var j;
        return Pn(k) ? ((j = k.getHead) == null ? void 0 : j.call(k, { location: s })) ?? [] : [];
      }
    ).map((k, j) => /* @__PURE__ */ o.jsx(zt, { children: k }, j));
    return /* @__PURE__ */ o.jsxs(o.Fragment, { children: [
      x,
      /* @__PURE__ */ o.jsx(Mt.Provider, { value: u, children: /* @__PURE__ */ o.jsxs(so, { context: yr, children: [
        /* @__PURE__ */ o.jsx(ro, {}),
        /* @__PURE__ */ o.jsx(Qn, { components: n, children: /* @__PURE__ */ o.jsx(Rs, { attribute: "class", disableTransitionOnChange: !0, children: /* @__PURE__ */ o.jsx(to, { value: t, children: /* @__PURE__ */ o.jsx(Js, { slotlets: e.slotlets, children: /* @__PURE__ */ o.jsx(wn, { children: r ?? /* @__PURE__ */ o.jsx(Tr, {}) }) }) }) }) })
      ] }) })
    ] });
  }
);
ls.displayName = "ZudokoInner";
const fs = (r) => /* @__PURE__ */ o.jsx(Yi, { FallbackComponent: Xi, children: /* @__PURE__ */ o.jsx(ls, { ...r }) });
fs.displayName = "Zudoku";
const Oo = Fr, Ao = Vi, Po = Xs, Ro = Xn, Mo = ra, Io = sa, Zo = Ps, $o = zt, no = ne, Do = Be, zo = Ks, Fo = Gs, qo = fs, Lo = Hi, Bo = en, Vo = kn, Uo = Ir, Qo = kt, Ho = Pr, Wo = Ft, Yo = jr, Ko = hi;
export {
  Ho as B,
  Fo as C,
  $o as H,
  Wo as L,
  Vo as M,
  Po as R,
  Ro as S,
  qo as Z,
  Do as a,
  no as b,
  Oo as c,
  Ao as d,
  Mo as e,
  Io as f,
  Zo as g,
  zo as h,
  Lo as i,
  Bo as j,
  Uo as k,
  Qo as l,
  Yo as m,
  Ko as n,
  Fr as u
};
//# sourceMappingURL=index-DnQftvP4.js.map
